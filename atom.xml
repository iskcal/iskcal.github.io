<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ThinLin</title>
  <subtitle>意义大于目的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iskcal.github.io/"/>
  <updated>2017-02-26T12:45:02.145Z</updated>
  <id>http://iskcal.github.io/</id>
  
  <author>
    <name>Iskcal</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kindle</title>
    <link href="http://iskcal.github.io/2017/02/26/kindle/"/>
    <id>http://iskcal.github.io/2017/02/26/kindle/</id>
    <published>2017-02-26T12:21:15.000Z</published>
    <updated>2017-02-26T12:45:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>元宵前买的kindle到今天终于到了，亚马逊似乎这款kindle卖的挺火的，一直无货，我隔了几乎有两个多星期才拿到手。</p>
<p>说起来，去年有想买kindle的念头，但是一直犹犹豫豫的，今年总算下定决心买来一个玩玩。之所以想买这个，纯粹就是希望自己能够多看点书吧。</p>
<p>另外，保护套颜色总感觉有点怪怪的，颜色太淡了，感觉适合女生用。嘛，算了，已经拿了，就凑合着用吧。</p>
<p>买了两本书，一本和心理学相关，叫《自控力》；另一本好像是小说，还没看，叫《皆有杂货铺》。前者看了一点，感觉还有点启发，要不回头试试写写笔记？后者还没看，不过听说口碑不错，好像还要改编成电影，也趁好看看。</p>
<p>以前总觉得书这种东西，只看专业书籍就行了，其他的书籍都在浪费时间。嗯，今年倒是想看看一些其他方面的书了，就当培养点耐心和爱好，拓展下视野吧。毕竟想改变也得做才行啊。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/kindle.jpg" alt="kindle" title="">
                </div>
                <div class="image-caption">kindle</div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元宵前买的kindle到今天终于到了，亚马逊似乎这款kindle卖的挺火的，一直无货，我隔了几乎有两个多星期才拿到手。&lt;/p&gt;
&lt;p&gt;说起来，去年有想买kindle的念头，但是一直犹犹豫豫的，今年总算下定决心买来一个玩玩。之所以想买这个，纯粹就是希望自己能够多看点书吧。&lt;/
    
    </summary>
    
      <category term="生活" scheme="http://iskcal.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://iskcal.github.io/tags/life/"/>
    
      <category term="book" scheme="http://iskcal.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>python中的装饰器</title>
    <link href="http://iskcal.github.io/2017/02/25/python-decoration/"/>
    <id>http://iskcal.github.io/2017/02/25/python-decoration/</id>
    <published>2017-02-25T02:53:37.000Z</published>
    <updated>2017-02-25T04:31:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器的由来"><a href="#装饰器的由来" class="headerlink" title="装饰器的由来"></a>装饰器的由来</h1><p>装饰器的出现，主要是由于两大原因。一是我们希望在调用一个函数前后执行某种逻辑操作，比如说验证信息、统计函数执行时间；二来这种操作非常普遍，普遍到有大量的函数都需要这种逻辑。如果说我们在每个函数前后都编写这样的逻辑，会产生复制-粘贴的结果，这种情况下对共有逻辑的修改是非常不利的。在Python中提供了装饰器来减少这种代码，使得那些需要同一个逻辑的函数只需要共用一份代码，共有逻辑的修改仅仅需要一次即可。</p>
<h1 id="装饰器的构造"><a href="#装饰器的构造" class="headerlink" title="装饰器的构造"></a>装饰器的构造</h1><p>我们先通过一个例子来看看装饰器，该例子所用的装饰器是计算某个函数一共调用了多少次，并在函数执行完毕后输出次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 装饰函数，计算给定的函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> count</div><div class="line">        count += <span class="number">1</span></div><div class="line">        func()</div><div class="line">        print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line"></div><div class="line"><span class="meta">@recordCall</span></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div></pre></td></tr></table></figure>
<p>这个例子的代码和之前<a href="/2017/02/24/python-closure/#nonlocal-语句">闭包</a>几乎完全一样，但是这里在第11行的语句确是原先没有的，但实际上这句话就是一个语法糖，它等价于<code>testFunction = recordCall(testFunction)</code>。因此，在这句话里面，实际上可以认为它把<code>testFunction</code>函数挂到<code>counter</code>方法体上了，执行<code>testFunction</code>函数并不是执行原本的函数体，而是<code>counter</code>方法体。这样达到了函数计数的目的。</p>
<h1 id="带参的装饰器"><a href="#带参的装饰器" class="headerlink" title="带参的装饰器"></a>带参的装饰器</h1><p>有很多时候，往往装饰函数内部的数据也希望不是固定的，我们希望有些参数是外部传进来的而不是取固定值。比如说上例中，我们默认<code>count</code>变量是从<code>0</code>开始取值的，但有时候我们希望这个值是外部给出的而不是写死的。其思路也很简单，我们可以把上面的装饰器看成是一个特定值的装饰器，然后在该装饰器外面再套一个函数用于给定数据变量就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 外层装饰函数，用于输入确定值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(start)</span>:</span></div><div class="line"><span class="comment"># 装饰函数，计算给定的函数调用多少次</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">        count = start</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">nonlocal</span> count</div><div class="line">            count += <span class="number">1</span></div><div class="line">            func()</div><div class="line">            print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">        <span class="keyword">return</span> counter</div><div class="line">    <span class="keyword">return</span> recordCall</div><div class="line"></div><div class="line"><span class="meta">@deco(5)</span></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第6次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第7次调用</span></div></pre></td></tr></table></figure>
<p>例子中展现的就是装饰器带参数，这种情况下还是比较多的，比如说在Flask框架中，用参数来指明某个函数应用于哪个路由。</p>
<h1 id="多装饰器组合使用"><a href="#多装饰器组合使用" class="headerlink" title="多装饰器组合使用"></a>多装饰器组合使用</h1><p>由于装饰完成后仍是一个函数，仍可以用装饰器再装饰，因此可以使用多个装饰器来修饰一个函数，也可以使用多个同一个装饰器来修饰一个函数，比如上例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(start)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">        count = start</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">nonlocal</span> count</div><div class="line">            count += <span class="number">1</span></div><div class="line">            func()</div><div class="line">            print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">        <span class="keyword">return</span> counter</div><div class="line">    <span class="keyword">return</span> recordCall</div><div class="line"></div><div class="line"><span class="meta">@deco(5)</span></div><div class="line"><span class="meta">@deco(0)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line"><span class="comment"># 第6次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div><div class="line"><span class="comment"># 第7次调用</span></div></pre></td></tr></table></figure>
<p>装饰的顺序是，首先<code>testFunction</code>函数会被<code>deco(0)</code>所装饰，所得函数会被<code>deco(5)</code>再次装饰，因而执行的顺序是<code>deco(0)</code>再是<code>deco(5)</code>。</p>
<h1 id="Python-内置装饰器"><a href="#Python-内置装饰器" class="headerlink" title="Python 内置装饰器"></a>Python 内置装饰器</h1><p>在 Python 中有一个内置的常用装饰器<code>wraps</code>。在说明这个装饰器之前，我们回到初始的例子。在初始代码执行完毕后，执行下面这句话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">... </span><span class="comment"># 原先代码</span></div><div class="line"></div><div class="line">print(testFunction.__name__)</div><div class="line"><span class="comment"># 输出： counter</span></div></pre></td></tr></table></figure>
<p>这句话的意思是打印这个函数的名字，可以看到，这个函数名字已经被修改成<code>counter</code>而不是原本的<code>testFunction</code>。可能一般情况下编程没有什么，但是一旦扯上反射，通过名字来寻找相应函数就会出现问题。我们希望该函数的名字仍是其原本的函数，这样可以使用<code>wraps</code>装饰器来解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="comment"># 装饰函数，计算给定的函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line"><span class="meta">    @ functools.wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> count</div><div class="line">        count += <span class="number">1</span></div><div class="line">        func()</div><div class="line">        print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line"></div><div class="line"><span class="meta">@recordCall</span></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div><div class="line"></div><div class="line">print(testFunction.__name__)</div><div class="line"><span class="comment"># 输出： testFunction</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰器的由来&quot;&gt;&lt;a href=&quot;#装饰器的由来&quot; class=&quot;headerlink&quot; title=&quot;装饰器的由来&quot;&gt;&lt;/a&gt;装饰器的由来&lt;/h1&gt;&lt;p&gt;装饰器的出现，主要是由于两大原因。一是我们希望在调用一个函数前后执行某种逻辑操作，比如说验证信息、统计函数执
    
    </summary>
    
      <category term="技术" scheme="http://iskcal.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://iskcal.github.io/tags/python/"/>
    
      <category term="装饰器" scheme="http://iskcal.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python中的闭包</title>
    <link href="http://iskcal.github.io/2017/02/24/python-closure/"/>
    <id>http://iskcal.github.io/2017/02/24/python-closure/</id>
    <published>2017-02-24T06:45:27.000Z</published>
    <updated>2017-02-24T08:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包这个概念，在函数式编程语言用的非常多，由于Python也具有一定的函数式编程的能力，自然也就会有闭包了。</p>
<p>我们先来看看闭包是啥。简而言之，即某个函数A返回一个函数B，但函数B包含一些函数A中的变量。用Python代码表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_config</span><span class="params">(k, b)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(x)</span>:</span></div><div class="line">        <span class="keyword">return</span> k*x+b</div><div class="line">    <span class="keyword">return</span> line</div><div class="line"></div><div class="line">line1 = line_config(<span class="number">2</span>, <span class="number">0</span>)</div><div class="line">print(line1(<span class="number">4</span>))  <span class="comment"># 输出8</span></div><div class="line">line2 = line_config(<span class="number">1</span>, <span class="number">0</span>)</div><div class="line">print(line2(<span class="number">3</span>))  <span class="comment"># 输出3</span></div></pre></td></tr></table></figure>
<p>可以看到，这里在<code>line_config</code>函数内部又定义了一个<code>line</code>函数。不仅如此，还有在<code>line</code>函数内部使用了其外部函数中的<code>k</code>和<code>b</code>变量。我们在<code>line_config</code>函数的范围内定义了函数<code>line</code>只能在<code>line_config</code>函数作用范围内使用。但实际情况是，内部定义的函数不仅可以在外部使用（第6行），而且还可以在外部调用时仍可以使用之前已经执行完成的<code>k</code>和<code>b</code>变量，这两点并不符合变量作用域范围的常识。这里，我们把这两个不符合作用域范围的变量<code>k</code>和<code>b</code>称之为环境变量，而内部的<code>line</code>函数和其环境变量合在一起，就形成了一个闭包(closure)。</p>
<h1 id="闭包有什么用呢"><a href="#闭包有什么用呢" class="headerlink" title="闭包有什么用呢"></a>闭包有什么用呢</h1><p>很多人初次见到闭包，往往只认为它是一种新特性，并且这种特性似乎只增加了一种新概念，对于编程似乎没有多大的提升，反而使得简单的问题复杂化。那么为什么要有闭包呢？一个字，懒。这种新特性只是简化代码的编写，并使得可读性变得更强。其具体体现在Python的一个强大的功能：装饰器，关于装饰器这里暂且不表。我们就对上面的一个例子做个分析吧。</p>
<p>有人肯定会说，上面的例子太麻烦了，写成下面这样的更好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(k, b, x)</span>:</span></div><div class="line">    <span class="keyword">return</span> k*x + b</div></pre></td></tr></table></figure>
<p>看起来，下面这种代码非常少，仅仅2行足矣。但是如果有大量的线性函数需要表达，并且未来涉及到改动，那么后者的改动量实在太大了。举个例子，有50个线性函数，每个函数计算100个点，假如需要把某个函数进行修改，那么只修改一个函数后者就需要操作100次，而前者仅仅需要一次即可。</p>
<p>我们来看看闭包的代码，第6、7行相当于定义了一个线性函数。第7、9行相当于给定了一个x值，通过线性函数计算对应的y值。可以看出之后调用时斜率与截距会默认保存下来，也就是说内部函数保存了一个上下文环境，这个环境是实例性的，即不同的调用会产生不同的上下文，形成不同的线性函数。</p>
<h1 id="nonlocal-语句"><a href="#nonlocal-语句" class="headerlink" title="nonlocal 语句"></a>nonlocal 语句</h1><p>在Python中，内部函数默认是可以读自由变量的，但是并没有办法写。在 Python 2 中只能将这个自由变量提升到全局变量，但是这种方法潜在危害性太大，毕竟没有哪一门语言提倡使用全局变量。Python 3 中给出了另一种方法，使用 nonlocal 语句。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 闭包，用于记录func函数被调用了多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> count</div><div class="line">        count += <span class="number">1</span></div><div class="line">        func()</div><div class="line">        print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line"></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">callTime = recordCall(testFunction)</div><div class="line">callTime()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line">callTime()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div></pre></td></tr></table></figure>
<p>这是一个闭包非常常用且实际的例子，这里的闭包用于记录传入的函数（Python中可以把函数当作对象传入函数中）被调用多少次。这里其实有一点装饰器的影子。注意内部的函数，nonlocal语句用于查找其自由变量，接下来的语句就是对其进行修改赋值，再然后执行传入的函数，输出次数，逻辑就这么多。可以看到使用闭包后，可以对任意一个函数记录其次数，但是仍有漏洞，如果调用原来的<code>testFunction</code>，发现并不会记录次数。改进的方法也很简单，只需要把<code>callTime</code>改成原来的<code>testFunction</code>即可，即第15行改为<code>testFunction = recordCall(testFunction)</code>，那么在此之后，任意地方调用<code>testFunction()</code>都会记录次数并输出次数。</p>
<h1 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h1><p>在闭包这里，还需要说明的一点是，闭包只保存自由变量，并不保存自由变量的值。当调用内部函数时，才会去寻找自由变量的值。这点非常具有迷惑性，下面就是一个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></div><div class="line">    arr = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">return</span> i*i</div><div class="line">        arr.append(square)</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line"></div><div class="line">result = wrapper()</div><div class="line">print(result[<span class="number">0</span>]()) <span class="comment"># 输出 4</span></div><div class="line">print(result[<span class="number">1</span>]()) <span class="comment"># 输出 4</span></div><div class="line">print(result[<span class="number">2</span>]()) <span class="comment"># 输出 4</span></div></pre></td></tr></table></figure>
<p>头有点大，我们慢慢来看。首先先不管<code>square</code>函数，我们先只看<code>wrapper</code>函数，这个函数很一般，我们定义了一个列表<code>arr</code>，并用循环向内部添加了3个东西。之后，再看<code>square</code>函数，它定义在循环体内部，列表添加的是函数而不是值（<code>append</code>函数内部参数是<code>square</code>而不是<code>square()</code>，前者是函数，后者是值）。然后，函数的计算方式是序号的平方。最后调用这个函数，输出三个值，但是发现这三个值并不是 0,1,4 而是 4,4,4。这和我们的思考方式并不一样。</p>
<p>当然了，这里已经说过了自由变量会在调用的时候才会去查找相关值。因此，在第一次调用<code>result[0]()</code>这个函数时，它才会寻找<code>i</code>的值，此时i的值为2，返回4。之后几次调用，由于<code>i</code>值不变，因而都会返回4。如果要想实现我们之前所想的功能，只需要使用给定默认值即可，如下面代码，Python会在调用时保存相关的<code>i</code>值数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 默认参数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></div><div class="line">    arr = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(i=i)</span>:</span></div><div class="line">            <span class="keyword">return</span> i*i</div><div class="line">        arr.append(square)</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line"></div><div class="line">result = wrapper()</div><div class="line">print(result[<span class="number">0</span>]()) <span class="comment"># 输出 0</span></div><div class="line">print(result[<span class="number">1</span>]()) <span class="comment"># 输出 1</span></div><div class="line">print(result[<span class="number">2</span>]()) <span class="comment"># 输出 4</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h1&gt;&lt;p&gt;闭包这个概念，在函数式编程语言用的非常多，由于Python也具有一定的函数式编程的能力，自然也就会有闭包了。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://iskcal.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://iskcal.github.io/tags/python/"/>
    
      <category term="闭包" scheme="http://iskcal.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>博客正式启动啦</title>
    <link href="http://iskcal.github.io/2017/02/22/start/"/>
    <id>http://iskcal.github.io/2017/02/22/start/</id>
    <published>2017-02-22T10:20:28.000Z</published>
    <updated>2017-02-22T10:29:16.914Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/start.png" alt="博客启动" title="">
                </div>
                <div class="image-caption">博客启动</div>
            </figure>
<p>本博客正式启动了，虽然功能还有一些未完善，但是先跑起来再说吧。目前想法是在这里记录生活、学习、爱好等，把这里作为我自己的时间记录吧。就这样，加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
    
    </summary>
    
      <category term="生活" scheme="http://iskcal.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://iskcal.github.io/tags/life/"/>
    
  </entry>
  
</feed>
