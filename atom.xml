<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ThinLin</title>
  <subtitle>意义大于目的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iskcal.github.io/"/>
  <updated>2017-03-04T12:31:52.000Z</updated>
  <id>http://iskcal.github.io/</id>
  
  <author>
    <name>Iskcal</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解C#第二章：C# 1 所搭建的核心基础</title>
    <link href="http://iskcal.github.io/2017/03/04/CSharp%20In%20Depth/2-Core-foundations-building-on-CSharp/"/>
    <id>http://iskcal.github.io/2017/03/04/CSharp In Depth/2-Core-foundations-building-on-CSharp/</id>
    <published>2017-03-04T09:28:44.000Z</published>
    <updated>2017-03-04T12:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><h2 id="使用委托步骤"><a href="#使用委托步骤" class="headerlink" title="使用委托步骤"></a>使用委托步骤</h2><p>委托使用分成4步：</p>
<ol>
<li>声明委托类型</li>
<li>为委托实例的操作找到一个恰当的方法，即把什么方法挂载到委托上</li>
<li>创建委托实例</li>
<li>调用委托（<code>Invoke</code> 方法调用）</li>
</ol>
<h2 id="合并和删除委托"><a href="#合并和删除委托" class="headerlink" title="合并和删除委托"></a>合并和删除委托</h2><p>一个委托可以挂载上多个符合要求的函数（即函数的参数个数、参数类型和返回值类型相同）。</p>
<p><code>System.Delegate</code>类型的静态方法<code>Combine</code>和<code>Remove</code>函数可以向委托添加相应的函数。但这两个方法并不是在原委托上操作，而是生成一个新委托，因而委托是不易变的。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是对委托的进一步封装，它只允许在创建委托的类中调用委托，而在类外只能通过事件来把函数挂载到该委托上。</p>
<h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>C# 1 的类型系统是静态的、显式的和安全的。</p>
<p>但C# 1 中有几点却不够用。</p>
<ul>
<li>除数组外集合中只能是Object类型，这表示在内部可以装任意东西</li>
<li>缺乏协变和逆变</li>
</ul>
<h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><p>引用类型放在堆中，局部值类型放在堆栈中，引用类型中的值类型放在堆中。</p>
<p>值类型与<code>object</code>类型相互转化叫装箱和拆箱。装箱和拆箱会对性能有少许影响。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;委托&quot;&gt;&lt;a href=&quot;#委托&quot; class=&quot;headerlink&quot; title=&quot;委托&quot;&gt;&lt;/a&gt;委托&lt;/h1&gt;&lt;h2 id=&quot;使用委托步骤&quot;&gt;&lt;a href=&quot;#使用委托步骤&quot; class=&quot;headerlink&quot; title=&quot;使用委托步骤&quot;&gt;&lt;/a&gt;使
    
    </summary>
    
      <category term="读书笔记" scheme="http://iskcal.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C#" scheme="http://iskcal.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>自控力 第一章：意志力</title>
    <link href="http://iskcal.github.io/2017/03/04/Self%20control/self-control-1/"/>
    <id>http://iskcal.github.io/2017/03/04/Self control/self-control-1/</id>
    <published>2017-03-04T01:42:46.000Z</published>
    <updated>2017-03-04T02:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><ol>
<li><p>所谓意志力，即“我要做”、“我不要”和“我想要”三种力量。</p>
</li>
<li><p>在意志力挑战中获胜关键，在于学会使用原始本能，而不是反抗这些本能。</p>
</li>
<li><p>在做决定的时候，你必须意识到自己此刻需要意志力。</p>
</li>
<li><p>如果你心里还在想着其他事，那么冲动就会主导你的选择。</p>
</li>
<li><p>认识自己，注意那些是自己真正想做的，那些是自己掩饰意图而做的，换句话来说，注意自己做某件事的真正意图。</p>
</li>
</ol>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><ol>
<li><p>请选择一天，把做出来的决定记录下来。在这一天结束时，回想做出了哪些决定，分析哪些有利于你实现目标，哪些会消磨你的意志。坚持记录你的决定，还有助于减少在注意力分散时作决定，同时增强你的意志力。</p>
</li>
<li><p>利用一周的时间观察一下，你究竟如何屈服于冲动的。你甚至不用设定一个目标，只需要看看你能否及早意识到自己在做什么，什么样的想法、感受和情况最让你有冲动，想些什么或暗示什么最容易让你放弃冲动。</p>
</li>
<li><p>每天花5分钟训练大脑冥想</p>
</li>
</ol>
<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><ol>
<li>2017-3-3</li>
</ol>
<ul>
<li>7:30 决定早起 — 成功但拖延，差点上课迟到，不想起来</li>
<li>7:50~9:25 上课 — 成功</li>
<li>9:30~12:00 技能学习 — 失败，上了半上午的网，当天nintendo switch发售，全程在网络浏览相关信息，以及观看相关开箱直播</li>
<li>12:30~14:00 午睡 — 失败，因为下午没课，不太想睡</li>
<li>14:30~17:30 回顾论文，写论文报告 — 失败，不太想去实验室，结果在宿舍玩了一下午</li>
<li>19:00~22:30 赶论文报告 — 完成</li>
</ul>
<p>分析：早起还是需要的，个人感觉如果没有手机，可能执行效果会更好，接下来可能需要研究下如果没有手机如何查看时间的问题。上课不说了，技能学习需要找到一个点，感觉太大太空，需要再仔细琢磨琢磨。论文报告以后可以留在周五晚上写，没有必要在下午赶出来。</p>
<ol>
<li><p>通常会喜欢拖延，拖延拖延往往到最后就屈服冲动了。很多时候拖延会意识到，但是一想拖一会儿没什么就这么拖延下去了。还有对能否做完一件事抱有疑问，不自信，认为自己没有能力完成。</p>
</li>
<li><p>效果感觉不是很好，但还是要坚持做下去。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘抄&quot;&gt;&lt;a href=&quot;#摘抄&quot; class=&quot;headerlink&quot; title=&quot;摘抄&quot;&gt;&lt;/a&gt;摘抄&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;所谓意志力，即“我要做”、“我不要”和“我想要”三种力量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在意志力挑战中获胜关键，在于
    
    </summary>
    
      <category term="读书笔记" scheme="http://iskcal.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="life" scheme="http://iskcal.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>《解忧杂货店》 观后感</title>
    <link href="http://iskcal.github.io/2017/02/28/life/worrybook/"/>
    <id>http://iskcal.github.io/2017/02/28/life/worrybook/</id>
    <published>2017-02-28T12:17:06.000Z</published>
    <updated>2017-02-28T13:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于这本书，以前听说过，评价还不错，正好亚马逊也给我推荐了这本书，于是我就拿来读读看看了。结果发现，这本书越看越不错，花了两天整的时间把读完了，反正也没啥事，写写一些感想吧。</p>
<p>不得不说，《解忧杂货店》这本书条理清晰，阅读顺畅。其作者东野圭吾是一个写推理小说的作家，虽说这本书不是推理小说，但是整篇故事下来也可以看出作者在逻辑上的处理实力。</p>
<p>本书一共五个故事，五个看似单独不相关的故事，但是实际上都是发生在一个小镇中的事情。（<strong>前方有剧透</strong>）</p>
<h1 id="第一个故事"><a href="#第一个故事" class="headerlink" title="第一个故事"></a>第一个故事</h1><p>故事讲述的是在小镇中有一个废弃的杂货铺，名叫浪矢杂货铺。有一天，有三个小偷偷了东西后躲了进去，之后收到了一条远在过去的信，也就是说他们在与几十年前的人通信。信中讲述了一个女子在追求梦想和照顾身患绝症的男友之间做出抉择的事情。原来女子听说该杂货店能解决人烦恼，便把自己的烦恼告诉杂货铺，希望能得到指点。</p>
<p>故事是从三个小偷的角度叙述的，这篇故事作为开头，与其说是咨询烦恼，还不如说是给三人练手用的。</p>
<p>令我惊奇的是结尾，三人因知道之后几十年发生的事情，劝说她去照顾她男朋友。但是如果真心相爱的两个人，那么病床上的他真的愿意他所喜欢的人为了他放弃自己的理想么。</p>
<blockquote>
<p>“我比任何人都要爱你，想要永远和你在一起。如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望我坚持我的梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘过你，但请让我去追逐梦想吧。”</p>
</blockquote>
<p>虽然最终，她没有能参加奥运会，男朋友也去世了，但是按照她自己的话来说，就是“他最后对我说的那句谢谢你带给我的梦想，还有临终时满足的表情，对我来说就是最大的奖赏”。</p>
<h1 id="第二个故事"><a href="#第二个故事" class="headerlink" title="第二个故事"></a>第二个故事</h1><p>说真，第二个故事可以说是我印象中最深的一个了。一个为了梦想不顾一切的人，为了音乐，努力学习，为了音乐，放弃学业，为了音乐，在酒吧卖唱。看看开头，多像一个鸡汤文，然后被某某星探发现，从此就成为了一个著名的音乐人。但是这里啊，主角只是一个普通人，普通到专业人士只认为他的水平一般，走歌手路子行不通。</p>
<p>故事以奶奶的葬礼开始的，就像一些文章中落魄的主角一样，回到老家，看似父母的强烈反对学音乐，实际上也能看出父母希望他能坚持他的梦想。于是他向杂货铺咨询，三人因知未来事，劝他在家子继父业，然而在最后一封信中却给出了这样一段文字：</p>
<blockquote>
<p>你对音乐的执着追求，绝不是白白付出。我相信，将会有人因为你的歌而得到救赎。你创作的音乐也必将流传下去。若要问我为何能如此断言，我也很难回答，但这确实是事实。请你始终坚信这一点，坚信到生命的最后一刻。</p>
</blockquote>
<p>回过头来再看看这段话，确实令人感慨。主角在孤儿院用生命拯救了一个小男孩，而这位男孩的姐姐在未来成为了一个歌星，并将主角创作的那首《重生》之歌流芳百世。</p>
<p>“你的穷途末路，却带给其他人未知的过往”。</p>
<h1 id="第三个故事"><a href="#第三个故事" class="headerlink" title="第三个故事"></a>第三个故事</h1><p>第三个故事讲述了杂货店接受咨询的起因，可以说是整本书的开头，老爷爷因偶然开始了咨询，但对待每个人每件事都是认真的。开始还是因为能帮助他人解决问题而特别高兴，但是随后却担心他人因自己的话语而走上并不幸福的道路。</p>
<p>借着咨询角度，这里又讲述了一个故事，故事里一个母亲说她怀了一个已婚之夫的孩子，她来咨询问到底要不要生出来，老爷爷并没有明确说明，只是说如果你确定要生下来，那么就要想好如何能照顾好他。可是在孩子生下不久，就因车祸去世了，万幸的是孩子没有事。但孩子一直以为母亲是带她一心赴死而埋恨她，直到最后孩子才发现母亲为了让她能存活下来，主动赴死。</p>
<p>“决定好了一件事，就要全力以赴地去做。”</p>
<h1 id="第四个故事"><a href="#第四个故事" class="headerlink" title="第四个故事"></a>第四个故事</h1><p>第四个故事讲述了亲情，这也是我印象中比较深的一个。</p>
<p>主角原本是家庭富裕的一家人，可是到了某天才发现，家里已经欠了不少钱。父母要带着主角跑路，隐姓埋名，然而主角埋怨父母，一个人跑了，从此成了一个孤儿。他原以为父母会隐姓埋名下来，等风头过了再去寻找他。结果最后得知，父母为了保护他，不惜以二人的死亡来彻底隐匿主角的身份。</p>
<p>“亲情，是可以超越生死的。”</p>
<h1 id="第五个故事"><a href="#第五个故事" class="headerlink" title="第五个故事"></a>第五个故事</h1><p>第五个故事把所有故事都给串起来了。</p>
<p>有一个女子来咨询如何获得经济独立，三人并不建议她去陪酒，并说，如果你相信我，那么我给你指一条路。女子后来听信了他们，并获得了巨大的成功，有一天她想回报当初帮助她的孤儿院，但是被他人诬陷。孤儿院中的三个小偷听信恶人，于是潜入她家偷东西，最后他们发现她就是当初他们帮助的那个人。整个故事刚好圆成了一个圈。</p>
<p>最后小偷三人测试性的递入了空白的资讯信，但是老爷爷给了一个非常漂亮的回答：因为你们还是一张白纸，因此你们可以随心所欲地描绘地图。整篇故事完结。</p>
<p>最后一个故事其实既说了三人组，也说了我们自己吧。</p>
<p>我想，整本书与其说是一个故事，更不如说是一部童话，治愈着人的心灵。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于这本书，以前听说过，评价还不错，正好亚马逊也给我推荐了这本书，于是我就拿来读读看看了。结果发现，这本书越看越不错，花了两天整的时间把读完了，反正也没啥事，写写一些感想吧。&lt;/p&gt;
&lt;p&gt;不得不说，《解忧杂货店》这本书条理清晰，阅读顺畅。其作者东野圭吾是一个写推理小说的作
    
    </summary>
    
      <category term="读后感" scheme="http://iskcal.github.io/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
      <category term="book" scheme="http://iskcal.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>深入理解C#第一章：C#开发的进化史</title>
    <link href="http://iskcal.github.io/2017/02/27/CSharp%20In%20Depth/1-The-changing-face-of-CSharp-development/"/>
    <id>http://iskcal.github.io/2017/02/27/CSharp In Depth/1-The-changing-face-of-CSharp-development/</id>
    <published>2017-02-27T10:58:24.000Z</published>
    <updated>2017-02-27T11:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章着重讲解C# 1到C# 5中的变化，微软为了让编写代码变得更加容易，在每个版本更迭中所添加的功能有一部分都在围绕如何让代码写起来更加的简单优雅。不仅如此，C# 每个版本中还会添加一些新的功能从而简化代码逻辑。</p>
<h1 id="代码演化"><a href="#代码演化" class="headerlink" title="代码演化"></a>代码演化</h1><p>由于本章是第一章，并不会着重讲述C#后续版本的特性，这里只提供一个大致的同一个功能的代码来描述各版本之间代码的异同以及为什么需要这样的变化。</p>
<p>老规矩，用产品、名称和价格的例子来作为描述对象。</p>
<h1 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CSharp 1</span></div><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product1</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">string</span> name;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">decimal</span> price;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Price &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> price; &#125; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product1</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">decimal</span> price</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">GetSampleProducts</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line">        list.Add(<span class="keyword">new</span> Product1(<span class="string">"West Side Story"</span>, <span class="number">9.99</span>m));</div><div class="line">        list.Add(<span class="keyword">new</span> Product1(<span class="string">"Assassins"</span>, <span class="number">14.99</span>m));</div><div class="line">        list.Add(<span class="keyword">new</span> Product1(<span class="string">"Frogs"</span>, <span class="number">13.99</span>m));</div><div class="line">        list.Add(<span class="keyword">new</span> Product1(<span class="string">"Sweeney Todd"</span>, <span class="number">10.99</span>m));</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;: &#123;1&#125;"</span>, name, price);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是最简单的C#代码，我相信很多人哪怕已经接触了更高的版本后仍会写出这样的代码，但这段代码有几个缺陷：</p>
<ul>
<li>ArrayList没有提供与内部内容有关的编译时信息。换句话而言，ArrayList内部保存的是基类Object，你可以往其内部添加任何玩意并不出错，但显然这不是我们所希望的。</li>
<li>代码内添加了公共的取值方法，这意味着如果添加对应的赋值方法，这也得是公共的。</li>
<li>创建属性和变量的代码很复杂。封装一个字符串和一个十进制数应该是是简单的任务，不需这么复杂。</li>
</ul>
<h1 id="第一次改进"><a href="#第一次改进" class="headerlink" title="第一次改进"></a>第一次改进</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CSharp 2</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product2</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">string</span> name;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">set</span> &#123; name = <span class="keyword">value</span>; &#125;    <span class="comment">//新的赋值权限</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">decimal</span> price;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Price</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> price; &#125;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">set</span> &#123;price = <span class="keyword">value</span>; &#125;    <span class="comment">//新的赋值权限</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product2</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">decimal</span> price</span>)</span></div><div class="line">    &#123;</div><div class="line">        Name = name;</div><div class="line">        Price = price;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Product2&gt; <span class="title">GetSampleProducts</span>(<span class="params"></span>)    <span class="comment">//采用泛型约束内部数据类型</span></span></div><div class="line">    &#123;</div><div class="line">        List&lt;Product2&gt; list = <span class="keyword">new</span> List&lt;Product&gt;();</div><div class="line">        list.Add(<span class="keyword">new</span> Product2(<span class="string">"West Side Story"</span>, <span class="number">9.99</span>m));</div><div class="line">        list.Add(<span class="keyword">new</span> Product2(<span class="string">"Assassins"</span>, <span class="number">14.99</span>m));</div><div class="line">        list.Add(<span class="keyword">new</span> Product2(<span class="string">"Frogs"</span>, <span class="number">13.99</span>m));</div><div class="line">        list.Add(<span class="keyword">new</span> Product2(<span class="string">"Sweeney Todd"</span>, <span class="number">10.99</span>m));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;: &#123;1&#125;"</span>, name, price);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，属性有了私有的赋值方法，并且集合内部约束了基本的数据类型，这样不能添加非<code>Product</code>类对象。C# 2解决了原先代码中的2个问题。还有一个问题，C# 3解决。</p>
<h1 id="第二次改进"><a href="#第二次改进" class="headerlink" title="第二次改进"></a>第二次改进</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CSharp 3</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product3</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;    <span class="comment">//属性创建缩短为一行</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product3</span>(<span class="params"></span>) </span>&#123;&#125;    <span class="comment">//新的构造函数，和书中不同，这里函数是public的</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Product3&gt; <span class="title">GetSampleProducts</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Product3&gt;</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">new</span> Product3&#123; Name=<span class="string">"West Side Story"</span>, Price=<span class="number">9.99</span>m&#125;,</div><div class="line">            <span class="keyword">new</span> Product3&#123; Name=<span class="string">"Assassins"</span>, Price=<span class="number">14.99</span>m&#125;,</div><div class="line">            <span class="keyword">new</span> Product3&#123; Name=<span class="string">"Frogs"</span>, Price=<span class="number">13.99</span>m&#125;,</div><div class="line">            <span class="keyword">new</span> Product3&#123; Name=<span class="string">"Sweeney Todd"</span>, Price=<span class="number">10.99</span>m&#125;,</div><div class="line">        &#125;;    <span class="comment">//新的集合构造表达式</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;: &#123;1&#125;"</span>, Name, Price);    <span class="comment">//属性当正常的字段使用</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，属性已经不会和任何的变量相关联，因此代码中原先所有的使用字段的地方都改成属性。</p>
<h1 id="第三次改进-（新加）"><a href="#第三次改进-（新加）" class="headerlink" title="第三次改进 （新加）"></a>第三次改进 （新加）</h1><p>但这里有个缺陷，当如果我们希望生成一个<code>Product</code>对象中就带有初值，而不需要在构造函数中给出，这种情况往往用于有些参数变量取默认值就好而不需要手动指明默认值。C# 6中属性的自动初始化可完成这个任务。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CSharp 6</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product6</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="string">"Sweeney Todd"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="number">13.99</span>m;    <span class="comment">//属性赋初值</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span>(<span class="params"></span>) </span>&#123;&#125;    <span class="comment">//新的构造函数，和书中不同，这里函数是public的</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Product6&gt; <span class="title">GetSampleProducts</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Product6&gt;</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">new</span> Product6&#123; Name=<span class="string">"West Side Story"</span>, Price=<span class="number">9.99</span>m&#125;,</div><div class="line">            <span class="keyword">new</span> Product6&#123; Name=<span class="string">"Assassins"</span>, Price=<span class="number">14.99</span>m&#125;,</div><div class="line">            <span class="keyword">new</span> Product6&#123; Name=<span class="string">"Frogs"</span>, Price=<span class="number">13.99</span>m&#125;,</div><div class="line">            <span class="keyword">new</span> Product6&#123; Name=<span class="string">"Sweeney Todd"</span>, Price=<span class="number">10.99</span>m&#125;,</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;Name&#125;</span> : <span class="subst">&#123;Price&#125;</span>"</span>;    <span class="comment">//新的字符串生成方法，类似于php中的操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当新建一个<code>Product</code>对象时，属性<code>Name</code>和<code>Price</code>就会赋上给定的相应初值，注意这个赋值操作是直接对字段操作而不是通过赋值属性操作而来的。</p>
<h1 id="剩余部分"><a href="#剩余部分" class="headerlink" title="剩余部分"></a>剩余部分</h1><p>本书之后还提到了C# 4中的命名实参，但我个人感觉C# 4中最大的特性不在于这而在于动态编程，因而这里不太细说了。</p>
<p>以上只是举了一个简单的例子来描述C#中各版本内的变化，不仅仅是以上提到的改动，还有一些比较大的改进。比如说委托在C# 1到C# 4几乎都有变化，甚至有些改动形成了一种新的编程方式，比如Linq，异步编程等。</p>
<p>后续部分我并没有说，不是说我认为不重要，而是因为我认为这些新特性会在后续章节详细说到，本章只作为引出开头，笔记做到这里就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章着重讲解C# 1到C# 5中的变化，微软为了让编写代码变得更加容易，在每个版本更迭中所添加的功能有一部分都在围绕如何让代码写起来更加的简单优雅。不仅如此，C# 每个版本中还会添加一些新的功能从而简化代码逻辑。&lt;/p&gt;
&lt;h1 id=&quot;代码演化&quot;&gt;&lt;a href=&quot;#代码
    
    </summary>
    
      <category term="读书笔记" scheme="http://iskcal.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C#" scheme="http://iskcal.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解C# 各章汇总</title>
    <link href="http://iskcal.github.io/2017/02/27/CSharp%20In%20Depth/0-Abstract/"/>
    <id>http://iskcal.github.io/2017/02/27/CSharp In Depth/0-Abstract/</id>
    <published>2017-02-27T02:49:56.000Z</published>
    <updated>2017-02-27T03:20:59.118Z</updated>
    
    <content type="html"><![CDATA[<p>这是我第一次开始尝试正式阅读一本书，嗯，以前多多少少看过一点书，但是经常看不了多少就放弃了，总觉得自己看不进去，也不能坚持下来。这次索性就边看边记录，看看自己能坚持多久。所谓好记性不如烂笔头，只看不写确实让人提不起什么兴趣。好了废话不多说，正式开始吧。</p>
<p>本书主要讲解的是C# 2及后续版本的更新要素。当初微软在创建C#之时，是以Java为蓝本抄袭过来的，因而C# 1的大多数功能和Java类似，之后便从C# 2开始加入了一系列的新特性和新功能，新的内容便是本书着重讲解的部分。</p>
<p>由于这本书出的已经有了几年了，C# 也从1发展到7了，但本书只讲述了C# 1 到C# 5 的情况，由于C# 7 暂时还未正式发布，并且 C# 6和C# 7 添加的功能不太多，很多东西属于语法糖的程度，因而我个人会在最后结尾处稍微提及一下。</p>
<p>本书分为五个部分和三个附录。五个部分基本对于C# 1到C# 5，附录列出了所有的参考资料，这里不做多叙述。</p>
<h1 id="第一部分：基础知识"><a href="#第一部分：基础知识" class="headerlink" title="第一部分：基础知识"></a>第一部分：基础知识</h1><p>这一部分主要讲述了C#的一些基础性知识以及C# 1中的概念，这是为后续的C# 版本做铺垫。</p>
<p><a href="/2017/02/27/CSharp%20In%20Depth/1-The-changing-face-of-CSharp-development/">第一章: C#进化史</a><br>[第二章：C# 1 所搭建的核心基础][2]</p>
<h1 id="第二部分：解决C-1-中的问题"><a href="#第二部分：解决C-1-中的问题" class="headerlink" title="第二部分：解决C# 1 中的问题"></a>第二部分：解决C# 1 中的问题</h1><p>这一部分主要讲述了C# 2 中的几个重大新特点：泛型、可空类型、委托、迭代器以及其他小特性</p>
<p>[第三章：用泛型实现参数化类型][3]<br>[第四章：可空类型][4]<br>[第五章：进入快速通道的委托][5]<br>[第六章：实现迭代器的捷径][6]<br>[第七章：结束C# 2的讲解：最后一些特性][7]</p>
<h1 id="第三部分：-C-3：革新写代码的方式"><a href="#第三部分：-C-3：革新写代码的方式" class="headerlink" title="第三部分： C# 3：革新写代码的方式"></a>第三部分： C# 3：革新写代码的方式</h1><p>这一部分整个C# 3 基本在围绕着Linq所服务的，并且其中很多特性在Linq之外也可以使用</p>
<p>[第八章：用智能的编译器来防错][8]<br>[第九章：Lambda表达式和表达式树][9]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次开始尝试正式阅读一本书，嗯，以前多多少少看过一点书，但是经常看不了多少就放弃了，总觉得自己看不进去，也不能坚持下来。这次索性就边看边记录，看看自己能坚持多久。所谓好记性不如烂笔头，只看不写确实让人提不起什么兴趣。好了废话不多说，正式开始吧。&lt;/p&gt;
&lt;p&gt;本书主
    
    </summary>
    
      <category term="读书笔记" scheme="http://iskcal.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C#" scheme="http://iskcal.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python函数中*号作用</title>
    <link href="http://iskcal.github.io/2017/02/26/wiki/python-star/"/>
    <id>http://iskcal.github.io/2017/02/26/wiki/python-star/</id>
    <published>2017-02-26T13:21:54.000Z</published>
    <updated>2017-02-26T13:40:11.733Z</updated>
    
    <content type="html"><![CDATA[<p>Python中既可以在实参中使用<code>*</code>，也可以在形参中使用<code>*</code>。</p>
<h1 id="形参中使用星号"><a href="#形参中使用星号" class="headerlink" title="形参中使用星号"></a>形参中使用星号</h1><p>这种使用方式比较常见。它可以看成是实参的打包。即该形参变量对应多个实参。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function1</span><span class="params">(*a, **b)</span>:</span></div><div class="line">    print(a)</div><div class="line">    print(b)</div><div class="line"></div><div class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">10</span>,y=<span class="number">11</span>)</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># (1,2,3)</span></div><div class="line"><span class="comment"># &#123;'x': 10, 'y': 11&#125;</span></div></pre></td></tr></table></figure>
<h1 id="实参中使用星号"><a href="#实参中使用星号" class="headerlink" title="实参中使用星号"></a>实参中使用星号</h1><p>这种使用方式并不太常见。它可以看成是实参的解包。即一个实参对应多个形参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function2</span><span class="params">(a, b, c, x, y)</span>:</span></div><div class="line">    print(<span class="string">"%s %s %s %s %s"</span> % (a, b, c, x, y))</div><div class="line"></div><div class="line">p1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">p2 = &#123;<span class="string">'x'</span>: <span class="number">10</span>, <span class="string">'y'</span>: <span class="number">11</span>&#125;</div><div class="line"></div><div class="line">function2(*p1, **p2)</div><div class="line"><span class="comment"># 输出：1 2 3 10 11</span></div></pre></td></tr></table></figure>
<p>这种方式常用于配置信息中，比如说被调用函数只需要它所要的配置信息数据，而调用时可以把整个配置信息字典传过去，方便代码编写。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中既可以在实参中使用&lt;code&gt;*&lt;/code&gt;，也可以在形参中使用&lt;code&gt;*&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;形参中使用星号&quot;&gt;&lt;a href=&quot;#形参中使用星号&quot; class=&quot;headerlink&quot; title=&quot;形参中使用星号&quot;&gt;&lt;/a&gt;形参
    
    </summary>
    
      <category term="wiki" scheme="http://iskcal.github.io/categories/wiki/"/>
    
    
      <category term="python" scheme="http://iskcal.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>kindle</title>
    <link href="http://iskcal.github.io/2017/02/26/life/kindle/"/>
    <id>http://iskcal.github.io/2017/02/26/life/kindle/</id>
    <published>2017-02-26T12:21:15.000Z</published>
    <updated>2017-02-26T12:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>元宵前买的kindle到今天终于到了，亚马逊似乎这款kindle卖的挺火的，一直无货，我隔了几乎有两个多星期才拿到手。</p>
<p>说起来，去年有想买kindle的念头，但是一直犹犹豫豫的，今年总算下定决心买来一个玩玩。之所以想买这个，纯粹就是希望自己能够多看点书吧。</p>
<p>另外，保护套颜色总感觉有点怪怪的，颜色太淡了，感觉适合女生用。嘛，算了，已经拿了，就凑合着用吧。</p>
<p>买了两本书，一本和心理学相关，叫《自控力》；另一本好像是小说，还没看，叫《解忧杂货铺》。前者看了一点，感觉还有点启发，要不回头试试写写笔记？后者还没看，不过听说口碑不错，好像还要改编成电影，也趁好提前看看。</p>
<p>以前总觉得书这种东西，只看专业书籍就行了，其他的书籍都在浪费时间。嗯，今年倒是想看看一些其他方面的书了，就当培养点耐心和爱好，拓展下视野吧。毕竟想改变也得做才行啊。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/kindle.jpg" alt="kindle" title="">
                </div>
                <div class="image-caption">kindle</div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元宵前买的kindle到今天终于到了，亚马逊似乎这款kindle卖的挺火的，一直无货，我隔了几乎有两个多星期才拿到手。&lt;/p&gt;
&lt;p&gt;说起来，去年有想买kindle的念头，但是一直犹犹豫豫的，今年总算下定决心买来一个玩玩。之所以想买这个，纯粹就是希望自己能够多看点书吧。&lt;/
    
    </summary>
    
      <category term="生活" scheme="http://iskcal.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://iskcal.github.io/tags/life/"/>
    
      <category term="book" scheme="http://iskcal.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>python中的装饰器</title>
    <link href="http://iskcal.github.io/2017/02/25/python-decoration/"/>
    <id>http://iskcal.github.io/2017/02/25/python-decoration/</id>
    <published>2017-02-25T02:53:37.000Z</published>
    <updated>2017-02-27T02:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器的由来"><a href="#装饰器的由来" class="headerlink" title="装饰器的由来"></a>装饰器的由来</h1><p>装饰器的出现，主要是由于两大原因。一是我们希望在调用一个函数前后执行某种逻辑操作，比如说验证信息、统计函数执行时间；二来这种操作非常普遍，普遍到有大量的函数都需要这种逻辑。如果说我们在每个函数前后都编写这样的逻辑，会产生复制-粘贴的结果，这种情况下对共有逻辑的修改是非常不利的。在Python中提供了装饰器来减少这种代码，使得那些需要同一个逻辑的函数只需要共用一份代码，共有逻辑的修改仅仅需要一次即可。</p>
<h1 id="装饰器的构造"><a href="#装饰器的构造" class="headerlink" title="装饰器的构造"></a>装饰器的构造</h1><p>我们先通过一个例子来看看装饰器，该例子所用的装饰器是计算某个函数一共调用了多少次，并在函数执行完毕后输出次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 装饰函数，计算给定的函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> count</div><div class="line">        count += <span class="number">1</span></div><div class="line">        func()</div><div class="line">        print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line"></div><div class="line"><span class="meta">@recordCall</span></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div></pre></td></tr></table></figure>
<p>这个例子的代码和之前<a href="/2017/02/24/python-closure/#nonlocal-语句">闭包</a>几乎完全一样，但是这里在第11行的语句确是原先没有的，但实际上这句话就是一个语法糖，它等价于<code>testFunction = recordCall(testFunction)</code>。因此，在这句话里面，实际上可以认为它把<code>testFunction</code>函数挂到<code>counter</code>方法体上了，执行<code>testFunction</code>函数并不是执行原本的函数体，而是<code>counter</code>方法体。这样达到了函数计数的目的。</p>
<h1 id="带参的装饰器"><a href="#带参的装饰器" class="headerlink" title="带参的装饰器"></a>带参的装饰器</h1><p>有很多时候，往往装饰函数内部的数据也希望不是固定的，我们希望有些参数是外部传进来的而不是取固定值。比如说上例中，我们默认<code>count</code>变量是从<code>0</code>开始取值的，但有时候我们希望这个值是外部给出的而不是写死的。其思路也很简单，我们可以把上面的装饰器看成是一个特定值的装饰器，然后在该装饰器外面再套一个函数用于给定数据变量就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 外层装饰函数，用于输入确定值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(start)</span>:</span></div><div class="line"><span class="comment"># 装饰函数，计算给定的函数调用多少次</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">        count = start</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">nonlocal</span> count</div><div class="line">            count += <span class="number">1</span></div><div class="line">            func()</div><div class="line">            print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">        <span class="keyword">return</span> counter</div><div class="line">    <span class="keyword">return</span> recordCall</div><div class="line"></div><div class="line"><span class="meta">@deco(5)</span></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第6次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第7次调用</span></div></pre></td></tr></table></figure>
<p>例子中展现的就是装饰器带参数，这种情况下还是比较多的，比如说在Flask框架中，用参数来指明某个函数应用于哪个路由。</p>
<h1 id="多装饰器组合使用"><a href="#多装饰器组合使用" class="headerlink" title="多装饰器组合使用"></a>多装饰器组合使用</h1><p>由于装饰完成后仍是一个函数，仍可以用装饰器再装饰，因此可以使用多个装饰器来修饰一个函数，也可以使用多个同一个装饰器来修饰一个函数，比如上例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(start)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">        count = start</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">nonlocal</span> count</div><div class="line">            count += <span class="number">1</span></div><div class="line">            func()</div><div class="line">            print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">        <span class="keyword">return</span> counter</div><div class="line">    <span class="keyword">return</span> recordCall</div><div class="line"></div><div class="line"><span class="meta">@deco(5)</span></div><div class="line"><span class="meta">@deco(0)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line"><span class="comment"># 第6次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div><div class="line"><span class="comment"># 第7次调用</span></div></pre></td></tr></table></figure>
<p>多装饰器的调用顺序是外部函数自底向上的，内部函数自顶向下的。这里，装饰的顺序是，首先<code>testFunction</code>函数会被<code>deco(0)</code>所装饰，所得函数会被<code>deco(5)</code>再次装饰。由于<code>print</code>语句位于内部函数中，因此内部函数执行顺序为先执行<code>count = 0</code>的<code>counter</code>函数，再执行<code>count=5</code>的<code>counter</code>函数。</p>
<h1 id="Python-内置装饰器"><a href="#Python-内置装饰器" class="headerlink" title="Python 内置装饰器"></a>Python 内置装饰器</h1><p>在 Python 中有一个内置的常用装饰器<code>wraps</code>。在说明这个装饰器之前，我们回到初始的例子。在初始代码执行完毕后，执行下面这句话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">... </span><span class="comment"># 原先代码</span></div><div class="line"></div><div class="line">print(testFunction.__name__)</div><div class="line"><span class="comment"># 输出： counter</span></div></pre></td></tr></table></figure>
<p>这句话的意思是打印这个函数的名字，可以看到，这个函数名字已经被修改成<code>counter</code>而不是原本的<code>testFunction</code>。可能一般情况下编程没有什么，但是一旦扯上反射，通过名字来寻找相应函数就会出现问题。我们希望该函数的名字仍是其原本的函数，这样可以使用<code>wraps</code>装饰器来解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="comment"># 装饰函数，计算给定的函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line"><span class="meta">    @ functools.wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> count</div><div class="line">        count += <span class="number">1</span></div><div class="line">        func()</div><div class="line">        print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line"></div><div class="line"><span class="meta">@recordCall</span></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line">testFunction()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div><div class="line"></div><div class="line">print(testFunction.__name__)</div><div class="line"><span class="comment"># 输出： testFunction</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰器的由来&quot;&gt;&lt;a href=&quot;#装饰器的由来&quot; class=&quot;headerlink&quot; title=&quot;装饰器的由来&quot;&gt;&lt;/a&gt;装饰器的由来&lt;/h1&gt;&lt;p&gt;装饰器的出现，主要是由于两大原因。一是我们希望在调用一个函数前后执行某种逻辑操作，比如说验证信息、统计函数执
    
    </summary>
    
      <category term="技术" scheme="http://iskcal.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://iskcal.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python中的闭包</title>
    <link href="http://iskcal.github.io/2017/02/24/python-closure/"/>
    <id>http://iskcal.github.io/2017/02/24/python-closure/</id>
    <published>2017-02-24T06:45:27.000Z</published>
    <updated>2017-02-27T03:21:02.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包这个概念，在函数式编程语言用的非常多，由于Python也具有一定的函数式编程的能力，自然也就会有闭包了。</p>
<p>我们先来看看闭包是啥。简而言之，即某个函数A返回一个函数B，但函数B包含一些函数A中的变量。用Python代码表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_config</span><span class="params">(k, b)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(x)</span>:</span></div><div class="line">        <span class="keyword">return</span> k*x+b</div><div class="line">    <span class="keyword">return</span> line</div><div class="line"></div><div class="line">line1 = line_config(<span class="number">2</span>, <span class="number">0</span>)</div><div class="line">print(line1(<span class="number">4</span>))  <span class="comment"># 输出8</span></div><div class="line">line2 = line_config(<span class="number">1</span>, <span class="number">0</span>)</div><div class="line">print(line2(<span class="number">3</span>))  <span class="comment"># 输出3</span></div></pre></td></tr></table></figure>
<p>可以看到，这里在<code>line_config</code>函数内部又定义了一个<code>line</code>函数。不仅如此，还有在<code>line</code>函数内部使用了其外部函数中的<code>k</code>和<code>b</code>变量。我们在<code>line_config</code>函数的范围内定义了函数<code>line</code>只能在<code>line_config</code>函数作用范围内使用。但实际情况是，内部定义的函数不仅可以在外部使用（第6行），而且还可以在外部调用时仍可以使用之前已经执行完成的<code>k</code>和<code>b</code>变量，这两点并不符合变量作用域范围的常识。这里，我们把这两个不符合作用域范围的变量<code>k</code>和<code>b</code>称之为环境变量，而内部的<code>line</code>函数和其环境变量合在一起，就形成了一个闭包(closure)。</p>
<h1 id="闭包有什么用呢"><a href="#闭包有什么用呢" class="headerlink" title="闭包有什么用呢"></a>闭包有什么用呢</h1><p>很多人初次见到闭包，往往只认为它是一种新特性，并且这种特性似乎只增加了一种新概念，对于编程似乎没有多大的提升，反而使得简单的问题复杂化。那么为什么要有闭包呢？一个字，懒。这种新特性只是简化代码的编写，并使得可读性变得更强。其具体体现在Python的一个强大的功能：装饰器，关于装饰器这里暂且不表。我们就对上面的一个例子做个分析吧。</p>
<p>有人肯定会说，上面的例子太麻烦了，写成下面这样的更好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(k, b, x)</span>:</span></div><div class="line">    <span class="keyword">return</span> k*x + b</div></pre></td></tr></table></figure>
<p>看起来，下面这种代码非常少，仅仅2行足矣。但是如果有大量的线性函数需要表达，并且未来涉及到改动，那么后者的改动量实在太大了。举个例子，有50个线性函数，每个函数计算100个点，假如需要把某个函数进行修改，那么只修改一个函数后者就需要操作100次，而前者仅仅需要一次即可。</p>
<p>我们来看看闭包的代码，第6、7行相当于定义了一个线性函数。第7、9行相当于给定了一个x值，通过线性函数计算对应的y值。可以看出之后调用时斜率与截距会默认保存下来，也就是说内部函数保存了一个上下文环境，这个环境是实例性的，即不同的调用会产生不同的上下文，形成不同的线性函数。</p>
<h1 id="nonlocal-语句"><a href="#nonlocal-语句" class="headerlink" title="nonlocal 语句"></a>nonlocal 语句</h1><p>在Python中，内部函数默认是可以读自由变量的，但是并没有办法写。在 Python 2 中只能将这个自由变量提升到全局变量，但是这种方法潜在危害性太大，毕竟没有哪一门语言提倡使用全局变量。Python 3 中给出了另一种方法，使用 nonlocal 语句。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 闭包，用于记录func函数被调用了多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recordCall</span><span class="params">(func)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> count</div><div class="line">        count += <span class="number">1</span></div><div class="line">        func()</div><div class="line">        print(<span class="string">"第%d次调用"</span> % count)</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line"></div><div class="line"><span class="comment"># 测试函数，结合闭包，用于测试该函数调用多少次</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testFunction</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hello world!"</span>)</div><div class="line"></div><div class="line">callTime = recordCall(testFunction)</div><div class="line">callTime()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第1次调用</span></div><div class="line">callTime()</div><div class="line"><span class="comment"># 输出</span></div><div class="line"><span class="comment"># Hello world!</span></div><div class="line"><span class="comment"># 第2次调用</span></div></pre></td></tr></table></figure>
<p>这是一个闭包非常常用且实际的例子，这里的闭包用于记录传入的函数（Python中可以把函数当作对象传入函数中）被调用多少次。这里其实有一点装饰器的影子。注意内部的函数，nonlocal语句用于查找其自由变量，接下来的语句就是对其进行修改赋值，再然后执行传入的函数，输出次数，逻辑就这么多。可以看到使用闭包后，可以对任意一个函数记录其次数，但是仍有漏洞，如果调用原来的<code>testFunction</code>，发现并不会记录次数。改进的方法也很简单，只需要把<code>callTime</code>改成原来的<code>testFunction</code>即可，即第15行改为<code>testFunction = recordCall(testFunction)</code>，那么在此之后，任意地方调用<code>testFunction()</code>都会记录次数并输出次数。</p>
<h1 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h1><p>在闭包这里，还需要说明的一点是，闭包只保存自由变量，并不保存自由变量的值。当调用内部函数时，才会去寻找自由变量的值。这点非常具有迷惑性，下面就是一个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></div><div class="line">    arr = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">return</span> i*i</div><div class="line">        arr.append(square)</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line"></div><div class="line">result = wrapper()</div><div class="line">print(result[<span class="number">0</span>]()) <span class="comment"># 输出 4</span></div><div class="line">print(result[<span class="number">1</span>]()) <span class="comment"># 输出 4</span></div><div class="line">print(result[<span class="number">2</span>]()) <span class="comment"># 输出 4</span></div></pre></td></tr></table></figure>
<p>头有点大，我们慢慢来看。首先先不管<code>square</code>函数，我们先只看<code>wrapper</code>函数，这个函数很一般，我们定义了一个列表<code>arr</code>，并用循环向内部添加了3个东西。之后，再看<code>square</code>函数，它定义在循环体内部，列表添加的是函数而不是值（<code>append</code>函数内部参数是<code>square</code>而不是<code>square()</code>，前者是函数，后者是值）。然后，函数的计算方式是序号的平方。最后调用这个函数，输出三个值，但是发现这三个值并不是 0,1,4 而是 4,4,4。这和我们的思考方式并不一样。</p>
<p>当然了，这里已经说过了自由变量会在调用的时候才会去查找相关值。因此，在第一次调用<code>result[0]()</code>这个函数时，它才会寻找<code>i</code>的值，此时i的值为2，返回4。之后几次调用，由于<code>i</code>值不变，因而都会返回4。如果要想实现我们之前所想的功能，只需要使用给定默认值即可，如下面代码，Python会在调用时保存相关的<code>i</code>值数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 默认参数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></div><div class="line">    arr = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(i=i)</span>:</span></div><div class="line">            <span class="keyword">return</span> i*i</div><div class="line">        arr.append(square)</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line"></div><div class="line">result = wrapper()</div><div class="line">print(result[<span class="number">0</span>]()) <span class="comment"># 输出 0</span></div><div class="line">print(result[<span class="number">1</span>]()) <span class="comment"># 输出 1</span></div><div class="line">print(result[<span class="number">2</span>]()) <span class="comment"># 输出 4</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h1&gt;&lt;p&gt;闭包这个概念，在函数式编程语言用的非常多，由于Python也具有一定的函数式编程的能力，自然也就会有闭包了。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://iskcal.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://iskcal.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>博客正式启动啦</title>
    <link href="http://iskcal.github.io/2017/02/22/life/start/"/>
    <id>http://iskcal.github.io/2017/02/22/life/start/</id>
    <published>2017-02-22T10:20:28.000Z</published>
    <updated>2017-02-22T10:29:16.914Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/start.png" alt="博客启动" title="">
                </div>
                <div class="image-caption">博客启动</div>
            </figure>
<p>本博客正式启动了，虽然功能还有一些未完善，但是先跑起来再说吧。目前想法是在这里记录生活、学习、爱好等，把这里作为我自己的时间记录吧。就这样，加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
    
    </summary>
    
      <category term="生活" scheme="http://iskcal.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="http://iskcal.github.io/tags/life/"/>
    
  </entry>
  
</feed>
