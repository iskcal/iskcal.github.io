{"meta":{"title":"ThinLin","subtitle":"意义大于目的","description":null,"author":"Iskcal","url":"http://iskcal.github.io"},"pages":[{"title":"","date":"2017-02-22T09:40:41.928Z","updated":"2017-02-22T09:40:41.928Z","comments":false,"path":"categories/index.html","permalink":"http://iskcal.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-22T09:41:02.528Z","updated":"2017-02-22T09:41:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://iskcal.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《解忧杂货店》 观后感","slug":"worrybook","date":"2017-02-28T12:17:06.000Z","updated":"2017-02-28T13:49:17.000Z","comments":true,"path":"2017/02/28/worrybook/","link":"","permalink":"http://iskcal.github.io/2017/02/28/worrybook/","excerpt":"","text":"关于这本书，以前听说过，评价还不错，正好亚马逊也给我推荐了这本书，于是我就拿来读读看看了。结果发现，这本书越看越不错，花了两天整的时间把读完了，反正也没啥事，写写一些感想吧。 不得不说，《解忧杂货店》这本书条理清晰，阅读顺畅。其作者东野圭吾是一个写推理小说的作家，虽说这本书不是推理小说，但是整篇故事下来也可以看出作者在逻辑上的处理实力。 本书一共五个故事，五个看似单独不相关的故事，但是实际上都是发生在一个小镇中的事情。（前方有剧透） 第一个故事故事讲述的是在小镇中有一个废弃的杂货铺，名叫浪矢杂货铺。有一天，有三个小偷偷了东西后躲了进去，之后收到了一条远在过去的信，也就是说他们在与几十年前的人通信。信中讲述了一个女子在追求梦想和照顾身患绝症的男友之间做出抉择的事情。原来女子听说该杂货店能解决人烦恼，便把自己的烦恼告诉杂货铺，希望能得到指点。 故事是从三个小偷的角度叙述的，这篇故事作为开头，与其说是咨询烦恼，还不如说是给三人练手用的。 令我惊奇的是结尾，三人因知道之后几十年发生的事情，劝说她去照顾她男朋友。但是如果真心相爱的两个人，那么病床上的他真的愿意他所喜欢的人为了他放弃自己的理想么。 “我比任何人都要爱你，想要永远和你在一起。如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望我坚持我的梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘过你，但请让我去追逐梦想吧。” 虽然最终，她没有能参加奥运会，男朋友也去世了，但是按照她自己的话来说，就是“他最后对我说的那句谢谢你带给我的梦想，还有临终时满足的表情，对我来说就是最大的奖赏”。 第二个故事说真，第二个故事可以说是我印象中最深的一个了。一个为了梦想不顾一切的人，为了音乐，努力学习，为了音乐，放弃学业，为了音乐，在酒吧卖唱。看看开头，多像一个鸡汤文，然后被某某星探发现，从此就成为了一个著名的音乐人。但是这里啊，主角只是一个普通人，普通到专业人士只认为他的水平一般，走歌手路子行不通。 故事以奶奶的葬礼开始的，就像一些文章中落魄的主角一样，回到老家，看似父母的强烈反对学音乐，实际上也能看出父母希望他能坚持他的梦想。于是他向杂货铺咨询，三人因知未来事，劝他在家子继父业，然而在最后一封信中却给出了这样一段文字： 你对音乐的执着追求，绝不是白白付出。我相信，将会有人因为你的歌而得到救赎。你创作的音乐也必将流传下去。若要问我为何能如此断言，我也很难回答，但这确实是事实。请你始终坚信这一点，坚信到生命的最后一刻。 回过头来再看看这段话，确实令人感慨。主角在孤儿院用生命拯救了一个小男孩，而这位男孩的姐姐在未来成为了一个歌星，并将主角创作的那首《重生》之歌流芳百世。 “你的穷途末路，却带给其他人未知的过往”。 第三个故事第三个故事讲述了杂货店接受咨询的起因，可以说是整本书的开头，老爷爷因偶然开始了咨询，但对待每个人每件事都是认真的。开始还是因为能帮助他人解决问题而特别高兴，但是随后却担心他人因自己的话语而走上并不幸福的道路。 借着咨询角度，这里又讲述了一个故事，故事里一个母亲说她怀了一个已婚之夫的孩子，她来咨询问到底要不要生出来，老爷爷并没有明确说明，只是说如果你确定要生下来，那么就要想好如何能照顾好他。可是在孩子生下不久，就因车祸去世了，万幸的是孩子没有事。但孩子一直以为母亲是带她一心赴死而埋恨她，直到最后孩子才发现母亲为了让她能存活下来，主动赴死。 “决定好了一件事，就要全力以赴地去做。” 第四个故事第四个故事讲述了亲情，这也是我印象中比较深的一个。 主角原本是家庭富裕的一家人，可是到了某天才发现，家里已经欠了不少钱。父母要带着主角跑路，隐姓埋名，然而主角埋怨父母，一个人跑了，从此成了一个孤儿。他原以为父母会隐姓埋名下来，等风头过了再去寻找他。结果最后得知，父母为了保护他，不惜以二人的死亡来彻底隐匿主角的身份。 “亲情，是可以超越生死的。” 第五个故事第五个故事把所有故事都给串起来了。 有一个女子来咨询如何获得经济独立，三人并不建议她去陪酒，并说，如果你相信我，那么我给你指一条路。女子后来听信了他们，并获得了巨大的成功，有一天她想回报当初帮助她的孤儿院，但是被他人诬陷。孤儿院中的三个小偷听信恶人，于是潜入她家偷东西，最后他们发现她就是当初他们帮助的那个人。整个故事刚好圆成了一个圈。 最后小偷三人测试性的递入了空白的资讯信，但是老爷爷给了一个非常漂亮的回答：因为你们还是一张白纸，因此你们可以随心所欲地描绘地图。整篇故事完结。 最后一个故事其实既说了三人组，也说了我们自己吧。 我想，整本书与其说是一个故事，更不如说是一部童话，治愈着人的心灵。","categories":[{"name":"读后感","slug":"读后感","permalink":"http://iskcal.github.io/categories/读后感/"}],"tags":[{"name":"book","slug":"book","permalink":"http://iskcal.github.io/tags/book/"}]},{"title":"深入理解C#第一章：C#开发的进化史","slug":"CSharp In Depth/1-The-changing-face-of-CSharp-development","date":"2017-02-27T10:58:24.000Z","updated":"2017-02-27T11:30:25.000Z","comments":true,"path":"2017/02/27/CSharp In Depth/1-The-changing-face-of-CSharp-development/","link":"","permalink":"http://iskcal.github.io/2017/02/27/CSharp In Depth/1-The-changing-face-of-CSharp-development/","excerpt":"","text":"本章着重讲解C# 1到C# 5中的变化，微软为了让编写代码变得更加容易，在每个版本更迭中所添加的功能有一部分都在围绕如何让代码写起来更加的简单优雅。不仅如此，C# 每个版本中还会添加一些新的功能从而简化代码逻辑。 代码演化由于本章是第一章，并不会着重讲述C#后续版本的特性，这里只提供一个大致的同一个功能的代码来描述各版本之间代码的异同以及为什么需要这样的变化。 老规矩，用产品、名称和价格的例子来作为描述对象。 原始代码12345678910111213141516171819202122232425262728293031//CSharp 1using System.Collections;public class Product1&#123; string name; public string Name &#123; get &#123; return name; &#125; &#125; decimal price; public decimal Price &#123; get &#123; return price; &#125; &#125; public Product1(string name, decimal price) &#123; this.name = name; this.price = price; &#125; public static ArrayList GetSampleProducts() &#123; ArrayList list = new ArrayList(); list.Add(new Product1(\"West Side Story\", 9.99m)); list.Add(new Product1(\"Assassins\", 14.99m)); list.Add(new Product1(\"Frogs\", 13.99m)); list.Add(new Product1(\"Sweeney Todd\", 10.99m)); return list; &#125; public override string ToString() &#123; return string.Format(\"&#123;0&#125;: &#123;1&#125;\", name, price); &#125;&#125; 这是最简单的C#代码，我相信很多人哪怕已经接触了更高的版本后仍会写出这样的代码，但这段代码有几个缺陷： ArrayList没有提供与内部内容有关的编译时信息。换句话而言，ArrayList内部保存的是基类Object，你可以往其内部添加任何玩意并不出错，但显然这不是我们所希望的。 代码内添加了公共的取值方法，这意味着如果添加对应的赋值方法，这也得是公共的。 创建属性和变量的代码很复杂。封装一个字符串和一个十进制数应该是是简单的任务，不需这么复杂。 第一次改进12345678910111213141516171819202122232425262728293031323334353637//CSharp 2public class Product2&#123; string name; public string Name &#123; get &#123; return name; &#125; private set &#123; name = value; &#125; //新的赋值权限 &#125; decimal price; public decimal Price &#123; get &#123; return price; &#125; private set &#123;price = value; &#125; //新的赋值权限 &#125; public Product2(string name, decimal price) &#123; Name = name; Price = price; &#125; public static List&lt;Product2&gt; GetSampleProducts() //采用泛型约束内部数据类型 &#123; List&lt;Product2&gt; list = new List&lt;Product&gt;(); list.Add(new Product2(\"West Side Story\", 9.99m)); list.Add(new Product2(\"Assassins\", 14.99m)); list.Add(new Product2(\"Frogs\", 13.99m)); list.Add(new Product2(\"Sweeney Todd\", 10.99m)); &#125; public override string ToString() &#123; return string.Format(\"&#123;0&#125;: &#123;1&#125;\", name, price); &#125;&#125; 这样一来，属性有了私有的赋值方法，并且集合内部约束了基本的数据类型，这样不能添加非Product类对象。C# 2解决了原先代码中的2个问题。还有一个问题，C# 3解决。 第二次改进123456789101112131415161718192021222324//CSharp 3public class Product3&#123; public string Name &#123; get; private set; &#125; public decimal Price &#123; get; private set; &#125; //属性创建缩短为一行 public Product3() &#123;&#125; //新的构造函数，和书中不同，这里函数是public的 public static List&lt;Product3&gt; GetSampleProducts() &#123; return new List&lt;Product3&gt; &#123; new Product3&#123; Name=\"West Side Story\", Price=9.99m&#125;, new Product3&#123; Name=\"Assassins\", Price=14.99m&#125;, new Product3&#123; Name=\"Frogs\", Price=13.99m&#125;, new Product3&#123; Name=\"Sweeney Todd\", Price=10.99m&#125;, &#125;; //新的集合构造表达式 &#125; public override string ToString() &#123; return string.Format(\"&#123;0&#125;: &#123;1&#125;\", Name, Price); //属性当正常的字段使用 &#125;&#125; 现在，属性已经不会和任何的变量相关联，因此代码中原先所有的使用字段的地方都改成属性。 第三次改进 （新加）但这里有个缺陷，当如果我们希望生成一个Product对象中就带有初值，而不需要在构造函数中给出，这种情况往往用于有些参数变量取默认值就好而不需要手动指明默认值。C# 6中属性的自动初始化可完成这个任务。 123456789101112131415161718192021222324//CSharp 6public class Product6&#123; public string Name &#123; get; private set; &#125; = \"Sweeney Todd\"; public decimal Price &#123; get; private set; &#125; = 13.99m; //属性赋初值 public Product() &#123;&#125; //新的构造函数，和书中不同，这里函数是public的 public static List&lt;Product6&gt; GetSampleProducts() &#123; return new List&lt;Product6&gt; &#123; new Product6&#123; Name=\"West Side Story\", Price=9.99m&#125;, new Product6&#123; Name=\"Assassins\", Price=14.99m&#125;, new Product6&#123; Name=\"Frogs\", Price=13.99m&#125;, new Product6&#123; Name=\"Sweeney Todd\", Price=10.99m&#125;, &#125;; &#125; public override string ToString() &#123; return $\"&#123;Name&#125; : &#123;Price&#125;\"; //新的字符串生成方法，类似于php中的操作 &#125;&#125; 当新建一个Product对象时，属性Name和Price就会赋上给定的相应初值，注意这个赋值操作是直接对字段操作而不是通过赋值属性操作而来的。 剩余部分本书之后还提到了C# 4中的命名实参，但我个人感觉C# 4中最大的特性不在于这而在于动态编程，因而这里不太细说了。 以上只是举了一个简单的例子来描述C#中各版本内的变化，不仅仅是以上提到的改动，还有一些比较大的改进。比如说委托在C# 1到C# 4几乎都有变化，甚至有些改动形成了一种新的编程方式，比如Linq，异步编程等。 后续部分我并没有说，不是说我认为不重要，而是因为我认为这些新特性会在后续章节详细说到，本章只作为引出开头，笔记做到这里就可以了。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/categories/读书笔记/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"}]},{"title":"深入理解C# 各章汇总","slug":"CSharp In Depth/0-Abstract","date":"2017-02-27T02:49:56.000Z","updated":"2017-02-27T03:20:59.118Z","comments":true,"path":"2017/02/27/CSharp In Depth/0-Abstract/","link":"","permalink":"http://iskcal.github.io/2017/02/27/CSharp In Depth/0-Abstract/","excerpt":"","text":"这是我第一次开始尝试正式阅读一本书，嗯，以前多多少少看过一点书，但是经常看不了多少就放弃了，总觉得自己看不进去，也不能坚持下来。这次索性就边看边记录，看看自己能坚持多久。所谓好记性不如烂笔头，只看不写确实让人提不起什么兴趣。好了废话不多说，正式开始吧。 本书主要讲解的是C# 2及后续版本的更新要素。当初微软在创建C#之时，是以Java为蓝本抄袭过来的，因而C# 1的大多数功能和Java类似，之后便从C# 2开始加入了一系列的新特性和新功能，新的内容便是本书着重讲解的部分。 由于这本书出的已经有了几年了，C# 也从1发展到7了，但本书只讲述了C# 1 到C# 5 的情况，由于C# 7 暂时还未正式发布，并且 C# 6和C# 7 添加的功能不太多，很多东西属于语法糖的程度，因而我个人会在最后结尾处稍微提及一下。 本书分为五个部分和三个附录。五个部分基本对于C# 1到C# 5，附录列出了所有的参考资料，这里不做多叙述。 第一部分：基础知识这一部分主要讲述了C#的一些基础性知识以及C# 1中的概念，这是为后续的C# 版本做铺垫。 第一章: C#进化史[第二章：C# 1 所搭建的核心基础][2] 第二部分：解决C# 1 中的问题这一部分主要讲述了C# 2 中的几个重大新特点：泛型、可空类型、委托、迭代器以及其他小特性 [第三章：用泛型实现参数化类型][3][第四章：可空类型][4][第五章：进入快速通道的委托][5][第六章：实现迭代器的捷径][6][第七章：结束C# 2的讲解：最后一些特性][7] 第三部分： C# 3：革新写代码的方式这一部分整个C# 3 基本在围绕着Linq所服务的，并且其中很多特性在Linq之外也可以使用 [第八章：用智能的编译器来防错][8][第九章：Lambda表达式和表达式树][9]","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/categories/读书笔记/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"}]},{"title":"python函数中*号作用","slug":"python-star","date":"2017-02-26T13:21:54.000Z","updated":"2017-02-26T13:40:11.733Z","comments":true,"path":"2017/02/26/python-star/","link":"","permalink":"http://iskcal.github.io/2017/02/26/python-star/","excerpt":"","text":"Python中既可以在实参中使用*，也可以在形参中使用*。 形参中使用星号这种使用方式比较常见。它可以看成是实参的打包。即该形参变量对应多个实参。 12345678def function1(*a, **b): print(a) print(b)func(1,2,3,x=10,y=11)# 输出# (1,2,3)# &#123;'x': 10, 'y': 11&#125; 实参中使用星号这种使用方式并不太常见。它可以看成是实参的解包。即一个实参对应多个形参 12345678def function2(a, b, c, x, y): print(\"%s %s %s %s %s\" % (a, b, c, x, y))p1 = [1, 2, 3]p2 = &#123;'x': 10, 'y': 11&#125;function2(*p1, **p2)# 输出：1 2 3 10 11 这种方式常用于配置信息中，比如说被调用函数只需要它所要的配置信息数据，而调用时可以把整个配置信息字典传过去，方便代码编写。","categories":[{"name":"wiki","slug":"wiki","permalink":"http://iskcal.github.io/categories/wiki/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"}]},{"title":"kindle","slug":"kindle","date":"2017-02-26T12:21:15.000Z","updated":"2017-02-26T12:56:14.000Z","comments":true,"path":"2017/02/26/kindle/","link":"","permalink":"http://iskcal.github.io/2017/02/26/kindle/","excerpt":"","text":"元宵前买的kindle到今天终于到了，亚马逊似乎这款kindle卖的挺火的，一直无货，我隔了几乎有两个多星期才拿到手。 说起来，去年有想买kindle的念头，但是一直犹犹豫豫的，今年总算下定决心买来一个玩玩。之所以想买这个，纯粹就是希望自己能够多看点书吧。 另外，保护套颜色总感觉有点怪怪的，颜色太淡了，感觉适合女生用。嘛，算了，已经拿了，就凑合着用吧。 买了两本书，一本和心理学相关，叫《自控力》；另一本好像是小说，还没看，叫《解忧杂货铺》。前者看了一点，感觉还有点启发，要不回头试试写写笔记？后者还没看，不过听说口碑不错，好像还要改编成电影，也趁好提前看看。 以前总觉得书这种东西，只看专业书籍就行了，其他的书籍都在浪费时间。嗯，今年倒是想看看一些其他方面的书了，就当培养点耐心和爱好，拓展下视野吧。毕竟想改变也得做才行啊。 kindle","categories":[{"name":"生活","slug":"生活","permalink":"http://iskcal.github.io/categories/生活/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"},{"name":"book","slug":"book","permalink":"http://iskcal.github.io/tags/book/"}]},{"title":"python中的装饰器","slug":"python-decoration","date":"2017-02-25T02:53:37.000Z","updated":"2017-02-27T02:33:25.000Z","comments":true,"path":"2017/02/25/python-decoration/","link":"","permalink":"http://iskcal.github.io/2017/02/25/python-decoration/","excerpt":"","text":"装饰器的由来装饰器的出现，主要是由于两大原因。一是我们希望在调用一个函数前后执行某种逻辑操作，比如说验证信息、统计函数执行时间；二来这种操作非常普遍，普遍到有大量的函数都需要这种逻辑。如果说我们在每个函数前后都编写这样的逻辑，会产生复制-粘贴的结果，这种情况下对共有逻辑的修改是非常不利的。在Python中提供了装饰器来减少这种代码，使得那些需要同一个逻辑的函数只需要共用一份代码，共有逻辑的修改仅仅需要一次即可。 装饰器的构造我们先通过一个例子来看看装饰器，该例子所用的装饰器是计算某个函数一共调用了多少次，并在函数执行完毕后输出次数。 1234567891011121314151617181920212223# 装饰函数，计算给定的函数调用多少次def recordCall(func): count = 0 def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter@recordCall# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用testFunction()# 输出# Hello world!# 第2次调用 这个例子的代码和之前闭包几乎完全一样，但是这里在第11行的语句确是原先没有的，但实际上这句话就是一个语法糖，它等价于testFunction = recordCall(testFunction)。因此，在这句话里面，实际上可以认为它把testFunction函数挂到counter方法体上了，执行testFunction函数并不是执行原本的函数体，而是counter方法体。这样达到了函数计数的目的。 带参的装饰器有很多时候，往往装饰函数内部的数据也希望不是固定的，我们希望有些参数是外部传进来的而不是取固定值。比如说上例中，我们默认count变量是从0开始取值的，但有时候我们希望这个值是外部给出的而不是写死的。其思路也很简单，我们可以把上面的装饰器看成是一个特定值的装饰器，然后在该装饰器外面再套一个函数用于给定数据变量就行了。 1234567891011121314151617181920212223242526# 外层装饰函数，用于输入确定值def deco(start):# 装饰函数，计算给定的函数调用多少次 def recordCall(func): count = start def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter return recordCall@deco(5)# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第6次调用testFunction()# 输出# Hello world!# 第7次调用 例子中展现的就是装饰器带参数，这种情况下还是比较多的，比如说在Flask框架中，用参数来指明某个函数应用于哪个路由。 多装饰器组合使用由于装饰完成后仍是一个函数，仍可以用装饰器再装饰，因此可以使用多个装饰器来修饰一个函数，也可以使用多个同一个装饰器来修饰一个函数，比如上例： 1234567891011121314151617181920212223242526def deco(start): def recordCall(func): count = start def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter return recordCall@deco(5)@deco(0)def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用# 第6次调用testFunction()# 输出# Hello world!# 第2次调用# 第7次调用 多装饰器的调用顺序是外部函数自底向上的，内部函数自顶向下的。这里，装饰的顺序是，首先testFunction函数会被deco(0)所装饰，所得函数会被deco(5)再次装饰。由于print语句位于内部函数中，因此内部函数执行顺序为先执行count = 0的counter函数，再执行count=5的counter函数。 Python 内置装饰器在 Python 中有一个内置的常用装饰器wraps。在说明这个装饰器之前，我们回到初始的例子。在初始代码执行完毕后，执行下面这句话： 1234... # 原先代码print(testFunction.__name__)# 输出： counter 这句话的意思是打印这个函数的名字，可以看到，这个函数名字已经被修改成counter而不是原本的testFunction。可能一般情况下编程没有什么，但是一旦扯上反射，通过名字来寻找相应函数就会出现问题。我们希望该函数的名字仍是其原本的函数，这样可以使用wraps装饰器来解决。 1234567891011121314151617181920212223242526272829import functools# 装饰函数，计算给定的函数调用多少次def recordCall(func): count = 0 @ functools.wraps(func) def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter@recordCall# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用testFunction()# 输出# Hello world!# 第2次调用print(testFunction.__name__)# 输出： testFunction","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"}]},{"title":"Python中的闭包","slug":"python-closure","date":"2017-02-24T06:45:27.000Z","updated":"2017-02-27T03:21:02.278Z","comments":true,"path":"2017/02/24/python-closure/","link":"","permalink":"http://iskcal.github.io/2017/02/24/python-closure/","excerpt":"","text":"什么是闭包闭包这个概念，在函数式编程语言用的非常多，由于Python也具有一定的函数式编程的能力，自然也就会有闭包了。 我们先来看看闭包是啥。简而言之，即某个函数A返回一个函数B，但函数B包含一些函数A中的变量。用Python代码表示为： 123456789def line_config(k, b): def line(x): return k*x+b return lineline1 = line_config(2, 0)print(line1(4)) # 输出8line2 = line_config(1, 0)print(line2(3)) # 输出3 可以看到，这里在line_config函数内部又定义了一个line函数。不仅如此，还有在line函数内部使用了其外部函数中的k和b变量。我们在line_config函数的范围内定义了函数line只能在line_config函数作用范围内使用。但实际情况是，内部定义的函数不仅可以在外部使用（第6行），而且还可以在外部调用时仍可以使用之前已经执行完成的k和b变量，这两点并不符合变量作用域范围的常识。这里，我们把这两个不符合作用域范围的变量k和b称之为环境变量，而内部的line函数和其环境变量合在一起，就形成了一个闭包(closure)。 闭包有什么用呢很多人初次见到闭包，往往只认为它是一种新特性，并且这种特性似乎只增加了一种新概念，对于编程似乎没有多大的提升，反而使得简单的问题复杂化。那么为什么要有闭包呢？一个字，懒。这种新特性只是简化代码的编写，并使得可读性变得更强。其具体体现在Python的一个强大的功能：装饰器，关于装饰器这里暂且不表。我们就对上面的一个例子做个分析吧。 有人肯定会说，上面的例子太麻烦了，写成下面这样的更好： 12def line(k, b, x): return k*x + b 看起来，下面这种代码非常少，仅仅2行足矣。但是如果有大量的线性函数需要表达，并且未来涉及到改动，那么后者的改动量实在太大了。举个例子，有50个线性函数，每个函数计算100个点，假如需要把某个函数进行修改，那么只修改一个函数后者就需要操作100次，而前者仅仅需要一次即可。 我们来看看闭包的代码，第6、7行相当于定义了一个线性函数。第7、9行相当于给定了一个x值，通过线性函数计算对应的y值。可以看出之后调用时斜率与截距会默认保存下来，也就是说内部函数保存了一个上下文环境，这个环境是实例性的，即不同的调用会产生不同的上下文，形成不同的线性函数。 nonlocal 语句在Python中，内部函数默认是可以读自由变量的，但是并没有办法写。在 Python 2 中只能将这个自由变量提升到全局变量，但是这种方法潜在危害性太大，毕竟没有哪一门语言提倡使用全局变量。Python 3 中给出了另一种方法，使用 nonlocal 语句。举个例子： 1234567891011121314151617181920212223# 闭包，用于记录func函数被调用了多少次def recordCall(func): count = 0 def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")callTime = recordCall(testFunction)callTime()# 输出# Hello world!# 第1次调用callTime()# 输出# Hello world!# 第2次调用 这是一个闭包非常常用且实际的例子，这里的闭包用于记录传入的函数（Python中可以把函数当作对象传入函数中）被调用多少次。这里其实有一点装饰器的影子。注意内部的函数，nonlocal语句用于查找其自由变量，接下来的语句就是对其进行修改赋值，再然后执行传入的函数，输出次数，逻辑就这么多。可以看到使用闭包后，可以对任意一个函数记录其次数，但是仍有漏洞，如果调用原来的testFunction，发现并不会记录次数。改进的方法也很简单，只需要把callTime改成原来的testFunction即可，即第15行改为testFunction = recordCall(testFunction)，那么在此之后，任意地方调用testFunction()都会记录次数并输出次数。 循环与闭包在闭包这里，还需要说明的一点是，闭包只保存自由变量，并不保存自由变量的值。当调用内部函数时，才会去寻找自由变量的值。这点非常具有迷惑性，下面就是一个例子。 123456789101112def wrapper(): arr = [] for i in range(3): def square(): return i*i arr.append(square) return arrresult = wrapper()print(result[0]()) # 输出 4print(result[1]()) # 输出 4print(result[2]()) # 输出 4 头有点大，我们慢慢来看。首先先不管square函数，我们先只看wrapper函数，这个函数很一般，我们定义了一个列表arr，并用循环向内部添加了3个东西。之后，再看square函数，它定义在循环体内部，列表添加的是函数而不是值（append函数内部参数是square而不是square()，前者是函数，后者是值）。然后，函数的计算方式是序号的平方。最后调用这个函数，输出三个值，但是发现这三个值并不是 0,1,4 而是 4,4,4。这和我们的思考方式并不一样。 当然了，这里已经说过了自由变量会在调用的时候才会去查找相关值。因此，在第一次调用result[0]()这个函数时，它才会寻找i的值，此时i的值为2，返回4。之后几次调用，由于i值不变，因而都会返回4。如果要想实现我们之前所想的功能，只需要使用给定默认值即可，如下面代码，Python会在调用时保存相关的i值数据。 12345678910111213# 默认参数def wrapper(): arr = [] for i in range(3): def square(i=i): return i*i arr.append(square) return arrresult = wrapper()print(result[0]()) # 输出 0print(result[1]()) # 输出 1print(result[2]()) # 输出 4","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"}]},{"title":"博客正式启动啦","slug":"start","date":"2017-02-22T10:20:28.000Z","updated":"2017-02-22T10:29:16.914Z","comments":true,"path":"2017/02/22/start/","link":"","permalink":"http://iskcal.github.io/2017/02/22/start/","excerpt":"","text":"博客启动 本博客正式启动了，虽然功能还有一些未完善，但是先跑起来再说吧。目前想法是在这里记录生活、学习、爱好等，把这里作为我自己的时间记录吧。就这样，加油。","categories":[{"name":"生活","slug":"生活","permalink":"http://iskcal.github.io/categories/生活/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"}]}]}