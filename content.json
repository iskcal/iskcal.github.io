{"meta":{"title":"ThinLin","subtitle":"意义大于目的","description":null,"author":"Iskcal","url":"http://iskcal.github.io"},"pages":[{"title":"","date":"2017-02-22T09:41:02.528Z","updated":"2017-02-22T09:41:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://iskcal.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-22T09:40:41.928Z","updated":"2017-02-22T09:40:41.928Z","comments":false,"path":"categories/index.html","permalink":"http://iskcal.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解C# 各章汇总","slug":"CSharp In Depth/0-Abstract","date":"2017-02-27T02:49:56.000Z","updated":"2017-02-27T02:54:57.000Z","comments":true,"path":"2017/02/27/CSharp In Depth/0-Abstract/","link":"","permalink":"http://iskcal.github.io/2017/02/27/CSharp In Depth/0-Abstract/","excerpt":"","text":"这是我第一次开始尝试正式阅读一本书，嗯，以前多多少少看过一点书，但是经常看不了多少就放弃了，总觉得自己看不进去，也不能坚持下来。这次索性就边看边记录，看看自己能坚持多久。所谓好记性不如烂笔头，只看不写确实让人提不起什么兴趣。好了废话不多说，正式开始吧。 本书主要讲解的是C# 2及后续版本的更新要素。当初微软在创建C#之时，是以Java为蓝本抄袭过来的，因而C# 1的大多数功能和Java类似，之后便从C# 2开始加入了一系列的新特性和新功能，新的内容便是本书着重讲解的部分。 由于这本书出的已经有了几年了，C# 也从1发展到7了，但本书只讲述了C# 1 到C# 5 的情况，由于C# 7 暂时还未正式发布，并且 C# 6和C# 7 添加的功能不太多，很多东西属于语法糖的程度，因而我个人会在最后结尾处稍微提及一下。 本书分为五个部分和三个附录。五个部分基本对于C# 1到C# 5，附录列出了所有的参考资料，这里不做多叙述。 #第一部分：基础知识，主要讲述了C#的一些基础性知识以及C# 1中的概念，这是为后续的C# 版本做铺垫。 [第一章: C#进化史][1][第二章：C# 1 所搭建的核心基础][2] 第二部分：解决C# 1 中的问题， 主要讲述了C# 2 中的几个重大新特点：泛型、可空类型、委托、迭代器以及其他小特性[第三章：用泛型实现参数化类型][3][第四章：可空类型][4][第五章：进入快速通道的委托][5][第六章：实现迭代器的捷径][6][第七章：结束C# 2的讲解：最后一些特性][7] 第三部分： C# 3：革新写代码的方式，整个C# 3 基本在围绕着Linq所服务的，并且其中很多特性在Linq之外也可以使用[第八章：用智能的编译器来防错][8][第九章：Lambda表达式和表达式树][9]","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/categories/读书笔记/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"},{"name":"生成器","slug":"生成器","permalink":"http://iskcal.github.io/tags/生成器/"},{"name":"Linq","slug":"Linq","permalink":"http://iskcal.github.io/tags/Linq/"}]},{"title":"python函数中*号作用","slug":"python-star","date":"2017-02-26T13:21:54.000Z","updated":"2017-02-26T13:40:11.733Z","comments":true,"path":"2017/02/26/python-star/","link":"","permalink":"http://iskcal.github.io/2017/02/26/python-star/","excerpt":"","text":"Python中既可以在实参中使用*，也可以在形参中使用*。 形参中使用星号这种使用方式比较常见。它可以看成是实参的打包。即该形参变量对应多个实参。 12345678def function1(*a, **b): print(a) print(b)func(1,2,3,x=10,y=11)# 输出# (1,2,3)# &#123;'x': 10, 'y': 11&#125; 实参中使用星号这种使用方式并不太常见。它可以看成是实参的解包。即一个实参对应多个形参 12345678def function2(a, b, c, x, y): print(\"%s %s %s %s %s\" % (a, b, c, x, y))p1 = [1, 2, 3]p2 = &#123;'x': 10, 'y': 11&#125;function2(*p1, **p2)# 输出：1 2 3 10 11 这种方式常用于配置信息中，比如说被调用函数只需要它所要的配置信息数据，而调用时可以把整个配置信息字典传过去，方便代码编写。","categories":[{"name":"wiki","slug":"wiki","permalink":"http://iskcal.github.io/categories/wiki/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"}]},{"title":"kindle","slug":"kindle","date":"2017-02-26T12:21:15.000Z","updated":"2017-02-26T12:56:14.000Z","comments":true,"path":"2017/02/26/kindle/","link":"","permalink":"http://iskcal.github.io/2017/02/26/kindle/","excerpt":"","text":"元宵前买的kindle到今天终于到了，亚马逊似乎这款kindle卖的挺火的，一直无货，我隔了几乎有两个多星期才拿到手。 说起来，去年有想买kindle的念头，但是一直犹犹豫豫的，今年总算下定决心买来一个玩玩。之所以想买这个，纯粹就是希望自己能够多看点书吧。 另外，保护套颜色总感觉有点怪怪的，颜色太淡了，感觉适合女生用。嘛，算了，已经拿了，就凑合着用吧。 买了两本书，一本和心理学相关，叫《自控力》；另一本好像是小说，还没看，叫《解忧杂货铺》。前者看了一点，感觉还有点启发，要不回头试试写写笔记？后者还没看，不过听说口碑不错，好像还要改编成电影，也趁好提前看看。 以前总觉得书这种东西，只看专业书籍就行了，其他的书籍都在浪费时间。嗯，今年倒是想看看一些其他方面的书了，就当培养点耐心和爱好，拓展下视野吧。毕竟想改变也得做才行啊。 kindle","categories":[{"name":"生活","slug":"生活","permalink":"http://iskcal.github.io/categories/生活/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"},{"name":"book","slug":"book","permalink":"http://iskcal.github.io/tags/book/"}]},{"title":"python中的装饰器","slug":"python-decoration","date":"2017-02-25T02:53:37.000Z","updated":"2017-02-27T02:33:25.000Z","comments":true,"path":"2017/02/25/python-decoration/","link":"","permalink":"http://iskcal.github.io/2017/02/25/python-decoration/","excerpt":"","text":"装饰器的由来装饰器的出现，主要是由于两大原因。一是我们希望在调用一个函数前后执行某种逻辑操作，比如说验证信息、统计函数执行时间；二来这种操作非常普遍，普遍到有大量的函数都需要这种逻辑。如果说我们在每个函数前后都编写这样的逻辑，会产生复制-粘贴的结果，这种情况下对共有逻辑的修改是非常不利的。在Python中提供了装饰器来减少这种代码，使得那些需要同一个逻辑的函数只需要共用一份代码，共有逻辑的修改仅仅需要一次即可。 装饰器的构造我们先通过一个例子来看看装饰器，该例子所用的装饰器是计算某个函数一共调用了多少次，并在函数执行完毕后输出次数。 1234567891011121314151617181920212223# 装饰函数，计算给定的函数调用多少次def recordCall(func): count = 0 def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter@recordCall# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用testFunction()# 输出# Hello world!# 第2次调用 这个例子的代码和之前闭包几乎完全一样，但是这里在第11行的语句确是原先没有的，但实际上这句话就是一个语法糖，它等价于testFunction = recordCall(testFunction)。因此，在这句话里面，实际上可以认为它把testFunction函数挂到counter方法体上了，执行testFunction函数并不是执行原本的函数体，而是counter方法体。这样达到了函数计数的目的。 带参的装饰器有很多时候，往往装饰函数内部的数据也希望不是固定的，我们希望有些参数是外部传进来的而不是取固定值。比如说上例中，我们默认count变量是从0开始取值的，但有时候我们希望这个值是外部给出的而不是写死的。其思路也很简单，我们可以把上面的装饰器看成是一个特定值的装饰器，然后在该装饰器外面再套一个函数用于给定数据变量就行了。 1234567891011121314151617181920212223242526# 外层装饰函数，用于输入确定值def deco(start):# 装饰函数，计算给定的函数调用多少次 def recordCall(func): count = start def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter return recordCall@deco(5)# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第6次调用testFunction()# 输出# Hello world!# 第7次调用 例子中展现的就是装饰器带参数，这种情况下还是比较多的，比如说在Flask框架中，用参数来指明某个函数应用于哪个路由。 多装饰器组合使用由于装饰完成后仍是一个函数，仍可以用装饰器再装饰，因此可以使用多个装饰器来修饰一个函数，也可以使用多个同一个装饰器来修饰一个函数，比如上例： 1234567891011121314151617181920212223242526def deco(start): def recordCall(func): count = start def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter return recordCall@deco(5)@deco(0)def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用# 第6次调用testFunction()# 输出# Hello world!# 第2次调用# 第7次调用 多装饰器的调用顺序是外部函数自底向上的，内部函数自顶向下的。这里，装饰的顺序是，首先testFunction函数会被deco(0)所装饰，所得函数会被deco(5)再次装饰。由于print语句位于内部函数中，因此内部函数执行顺序为先执行count = 0的counter函数，再执行count=5的counter函数。 Python 内置装饰器在 Python 中有一个内置的常用装饰器wraps。在说明这个装饰器之前，我们回到初始的例子。在初始代码执行完毕后，执行下面这句话： 1234... # 原先代码print(testFunction.__name__)# 输出： counter 这句话的意思是打印这个函数的名字，可以看到，这个函数名字已经被修改成counter而不是原本的testFunction。可能一般情况下编程没有什么，但是一旦扯上反射，通过名字来寻找相应函数就会出现问题。我们希望该函数的名字仍是其原本的函数，这样可以使用wraps装饰器来解决。 1234567891011121314151617181920212223242526272829import functools# 装饰函数，计算给定的函数调用多少次def recordCall(func): count = 0 @ functools.wraps(func) def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter@recordCall# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用testFunction()# 输出# Hello world!# 第2次调用print(testFunction.__name__)# 输出： testFunction","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://iskcal.github.io/tags/装饰器/"}]},{"title":"Python中的闭包","slug":"python-closure","date":"2017-02-24T06:45:27.000Z","updated":"2017-02-24T08:49:36.000Z","comments":true,"path":"2017/02/24/python-closure/","link":"","permalink":"http://iskcal.github.io/2017/02/24/python-closure/","excerpt":"","text":"什么是闭包闭包这个概念，在函数式编程语言用的非常多，由于Python也具有一定的函数式编程的能力，自然也就会有闭包了。 我们先来看看闭包是啥。简而言之，即某个函数A返回一个函数B，但函数B包含一些函数A中的变量。用Python代码表示为： 123456789def line_config(k, b): def line(x): return k*x+b return lineline1 = line_config(2, 0)print(line1(4)) # 输出8line2 = line_config(1, 0)print(line2(3)) # 输出3 可以看到，这里在line_config函数内部又定义了一个line函数。不仅如此，还有在line函数内部使用了其外部函数中的k和b变量。我们在line_config函数的范围内定义了函数line只能在line_config函数作用范围内使用。但实际情况是，内部定义的函数不仅可以在外部使用（第6行），而且还可以在外部调用时仍可以使用之前已经执行完成的k和b变量，这两点并不符合变量作用域范围的常识。这里，我们把这两个不符合作用域范围的变量k和b称之为环境变量，而内部的line函数和其环境变量合在一起，就形成了一个闭包(closure)。 闭包有什么用呢很多人初次见到闭包，往往只认为它是一种新特性，并且这种特性似乎只增加了一种新概念，对于编程似乎没有多大的提升，反而使得简单的问题复杂化。那么为什么要有闭包呢？一个字，懒。这种新特性只是简化代码的编写，并使得可读性变得更强。其具体体现在Python的一个强大的功能：装饰器，关于装饰器这里暂且不表。我们就对上面的一个例子做个分析吧。 有人肯定会说，上面的例子太麻烦了，写成下面这样的更好： 12def line(k, b, x): return k*x + b 看起来，下面这种代码非常少，仅仅2行足矣。但是如果有大量的线性函数需要表达，并且未来涉及到改动，那么后者的改动量实在太大了。举个例子，有50个线性函数，每个函数计算100个点，假如需要把某个函数进行修改，那么只修改一个函数后者就需要操作100次，而前者仅仅需要一次即可。 我们来看看闭包的代码，第6、7行相当于定义了一个线性函数。第7、9行相当于给定了一个x值，通过线性函数计算对应的y值。可以看出之后调用时斜率与截距会默认保存下来，也就是说内部函数保存了一个上下文环境，这个环境是实例性的，即不同的调用会产生不同的上下文，形成不同的线性函数。 nonlocal 语句在Python中，内部函数默认是可以读自由变量的，但是并没有办法写。在 Python 2 中只能将这个自由变量提升到全局变量，但是这种方法潜在危害性太大，毕竟没有哪一门语言提倡使用全局变量。Python 3 中给出了另一种方法，使用 nonlocal 语句。举个例子： 1234567891011121314151617181920212223# 闭包，用于记录func函数被调用了多少次def recordCall(func): count = 0 def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")callTime = recordCall(testFunction)callTime()# 输出# Hello world!# 第1次调用callTime()# 输出# Hello world!# 第2次调用 这是一个闭包非常常用且实际的例子，这里的闭包用于记录传入的函数（Python中可以把函数当作对象传入函数中）被调用多少次。这里其实有一点装饰器的影子。注意内部的函数，nonlocal语句用于查找其自由变量，接下来的语句就是对其进行修改赋值，再然后执行传入的函数，输出次数，逻辑就这么多。可以看到使用闭包后，可以对任意一个函数记录其次数，但是仍有漏洞，如果调用原来的testFunction，发现并不会记录次数。改进的方法也很简单，只需要把callTime改成原来的testFunction即可，即第15行改为testFunction = recordCall(testFunction)，那么在此之后，任意地方调用testFunction()都会记录次数并输出次数。 循环与闭包在闭包这里，还需要说明的一点是，闭包只保存自由变量，并不保存自由变量的值。当调用内部函数时，才会去寻找自由变量的值。这点非常具有迷惑性，下面就是一个例子。 123456789101112def wrapper(): arr = [] for i in range(3): def square(): return i*i arr.append(square) return arrresult = wrapper()print(result[0]()) # 输出 4print(result[1]()) # 输出 4print(result[2]()) # 输出 4 头有点大，我们慢慢来看。首先先不管square函数，我们先只看wrapper函数，这个函数很一般，我们定义了一个列表arr，并用循环向内部添加了3个东西。之后，再看square函数，它定义在循环体内部，列表添加的是函数而不是值（append函数内部参数是square而不是square()，前者是函数，后者是值）。然后，函数的计算方式是序号的平方。最后调用这个函数，输出三个值，但是发现这三个值并不是 0,1,4 而是 4,4,4。这和我们的思考方式并不一样。 当然了，这里已经说过了自由变量会在调用的时候才会去查找相关值。因此，在第一次调用result[0]()这个函数时，它才会寻找i的值，此时i的值为2，返回4。之后几次调用，由于i值不变，因而都会返回4。如果要想实现我们之前所想的功能，只需要使用给定默认值即可，如下面代码，Python会在调用时保存相关的i值数据。 12345678910111213# 默认参数def wrapper(): arr = [] for i in range(3): def square(i=i): return i*i arr.append(square) return arrresult = wrapper()print(result[0]()) # 输出 0print(result[1]()) # 输出 1print(result[2]()) # 输出 4","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"http://iskcal.github.io/tags/闭包/"}]},{"title":"博客正式启动啦","slug":"start","date":"2017-02-22T10:20:28.000Z","updated":"2017-02-22T10:29:16.914Z","comments":true,"path":"2017/02/22/start/","link":"","permalink":"http://iskcal.github.io/2017/02/22/start/","excerpt":"","text":"博客启动 本博客正式启动了，虽然功能还有一些未完善，但是先跑起来再说吧。目前想法是在这里记录生活、学习、爱好等，把这里作为我自己的时间记录吧。就这样，加油。","categories":[{"name":"生活","slug":"生活","permalink":"http://iskcal.github.io/categories/生活/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"}]}]}