{"meta":{"title":"ThinLin","subtitle":"意义大于目的","description":null,"author":"Iskcal","url":"http://iskcal.github.io"},"pages":[{"title":"","date":"2017-02-22T09:40:41.928Z","updated":"2017-02-22T09:40:41.928Z","comments":false,"path":"categories/index.html","permalink":"http://iskcal.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-22T09:41:02.528Z","updated":"2017-02-22T09:41:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://iskcal.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"健身房","slug":"gym","date":"2017-03-22T13:38:54.000Z","updated":"2017-03-22T13:44:56.000Z","comments":true,"path":"2017/03/22/gym/","link":"","permalink":"http://iskcal.github.io/2017/03/22/gym/","excerpt":"","text":"嗯，今天报了一个健身班。三个月的课程，看看能达到啥样的效果咯，让自己忙起来吧。话说确实好烧钱，终于有种钱不够花的感觉了。钱啊，真是一个好东西，我也想赚钱了=。=","categories":[{"name":"生活","slug":"生活","permalink":"http://iskcal.github.io/categories/生活/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"}]},{"title":"深入理解C#第四章：可空类型","slug":"CSharp In Depth/4-Saying-nothing-with-nullable-types","date":"2017-03-18T02:59:24.000Z","updated":"2017-03-18T05:20:00.000Z","comments":true,"path":"2017/03/18/CSharp In Depth/4-Saying-nothing-with-nullable-types/","link":"","permalink":"http://iskcal.github.io/2017/03/18/CSharp In Depth/4-Saying-nothing-with-nullable-types/","excerpt":"","text":"Nullable首先，它是一个泛型。类型参数T有一个值类型约束，另外，它不能是另一个可空类型，毕竟这是没有意义的。T也被称为基础类型。 Nullable&lt;T&gt;最重要的是两个属性HasValue和Value。前者表示该值是否为空，它是一个Boolean属性，后者表示如果有值，值为多少。 Nullable&lt;T&gt;有一个GetValueOrDefault的方法，它有两个重载。其主要作用是如果存在值，则返回该值，否则返回一个默认值。 装箱和拆箱可空类型还是一个值类型，因此也存在装箱和拆箱的问题。但可空类型的装箱和拆箱和其他的值类型有很大的区别。 装箱如果可空类型是空值，则装箱后是一个空引用。如果可空类型非空，则按照正常的装箱步骤装箱。 拆箱如果是空引用，拆箱成普通类型会抛出NullReferenceException异常，但拆成可空类型则会形成没有值的实例。如果是已装箱的值，则既可以拆成普通类型，也可以拆成对应的可空类型。 相等性Nullable&lt;T&gt;覆盖了object.Equals(object)。因此关于可空类型的相等判断也会出现一些变化，具体表现在调用first.Equals(second)上： 如果first没有值，second为null，它们就是相等的 如果first没有值，second不为null，它们就是不等的 如果first有值，second为null，它们就是不等的 如果first的值等于second值，它们就是相等的 这里对于second不用再考虑是否为可空类型的情况，因为做比较时，Equals函数只接受object对象，如果second是可空类型，则是以装箱的形式传入的，即要么为null要么不为空。 NullableNullable是一个静态类，包含三个静态函数，前两个是泛型方法，用于比较。第三个是普通方法，用于获取可空类型的基础类型。 1public static Type GetUnderlyingType(Type nullableType) 语法糖?修饰符简写修饰符，只是把相应的Nullable&lt;T&gt;简写成T?。 null比较和赋值之前说过可以把可空类型与null直接比较。不仅可以比较，也可以直接赋值，赋值为null意味着该可空类型没有值。 可空类型转换当非可空的值类型T重载了操作符后，可空类型T?自动便拥有了相同的操作符，但其操作数和结果类型不同，这被称为提升转换。 true和false操作符永远不会提升。 只有操作数是非可空值类型才会被提升。 对于一元和二元操作符（除相等关系操作符），返回结果必须是非可空值类型。 对于相等和关系操作符，返回类型必须是bool 对于bool?的&amp;和|操作方式有单独定义。 可空逻辑 x y x&amp;y x&#124;y x^y !x true true true true false false true false false true true false true null null true null false false true false true true true false false false false false true false null false null null true null true null true null null null false false null null null null null null null null null 记忆方式，把null当成即可能是true也可能是false。如果计算结果两者均可，则为null。 as以往as操作符只能用于引用类型，C# 2 中可以用于可空类型。其结果为可空类型的空值或有意义的值。 ??该操作符是二元操作符。求值first ?? second时，返回结果为: 对first进行求值 如果结果非空，则该结果为表达式结果 否则求second的值，其结果为整个表达式结果 一个可空类型的常用例子产品按照多个要求排序，比如，产品先按流行度再按价格最后按名称排序。 12345678910111213141516// C# 1 代码public int Compare(Product first, Product second)&#123; // 按照流行度从高到低排序 int ret = second.Popularity.CompareTo(first.Popularity); if (ret != 0) &#123; return ret; &#125; ret = first.Price.CompareTo(second.Price); if (ret != 0) &#123; return ret; &#125; return first.Name.CompareTo(second.Name);&#125; 该代码处只单纯做了两个数据的比较，如果再加上空值判断逻辑，会让代码显得更加臃肿。 123456789101112131415161718192021222324252627282930313233// 采用可空类型的新型比较public static class PartialComparer&#123; public static int? Compare&lt;T&gt; (T first, T second) &#123; return Compare(Comparer&lt;T&gt;.Default, first,second); &#125; public static int? Compare&lt;T&gt; (IComparer&lt;T&gt; comparer, T first, T second) &#123; int ret = comparer.Compare(first, second); return ret == 0 ? new int?() : ret; &#125; public static int? ReferenceCompare&lt;T&gt; (T first, T second) where T : class &#123; return first == second ? 0 : first == null ? -1 : second == null ? 1 : new int?(); &#125;&#125;// 具体比较public int Compare(Product first, Product second)&#123; return PartialComparer.ReferenceCompare(first, second) ?? //流行度从高到低排序 PartialComparer.Compare(second.Popularity, first.Popularity) ?? PartialComparer.comparer(first.Price, second.Price) ?? PartialComparer.Compare(first.Name, second.Name) ?? 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/tags/读书笔记/"}]},{"title":"深入理解C#第三章：用泛型实现参数化类型","slug":"CSharp In Depth/3-Parameterized-typing-with-generics","date":"2017-03-17T13:34:53.000Z","updated":"2017-03-18T03:05:07.330Z","comments":true,"path":"2017/03/17/CSharp In Depth/3-Parameterized-typing-with-generics/","link":"","permalink":"http://iskcal.github.io/2017/03/17/CSharp In Depth/3-Parameterized-typing-with-generics/","excerpt":"","text":"泛型泛型有两种形式：泛型类型（包括类、接口、委托和结构——没有泛型枚举）和泛型方法。 类型参数可以看成是真实类型的占位符，一旦确定了泛型的具体类型，即使用了真实的类型代替后，无法向该泛型中添加其他类型的数据。这些真实的类型被称为类型实参。 如果没有为泛型类型参数提供类型实参，则该泛型是一个未绑定泛型类型。如果指定了类型实参，则该泛型是一个已构造类型。已构造类型可以是开放或封闭的。开放类型还包含一个类型参数。而封闭类型则不是开放的。 泛型方法泛型方法是在函数名后使用尖括号来表示。比如： 1List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt;(Converter&lt;T, TOutput&gt; conv) 这里，似乎看的并不是很清楚。这里把它转换成一个具体类型。 1List&lt;Guid&gt; ConvertAll(Converter&lt;string, Guid&gt; conv) 现在，这个泛型方法中的所有类型参数都已经用类型实参替代了。这个方法看起来就非常明了。 方法返回一个List&lt;Guid&gt; 方法名是ConvertAll 方法只有一个参数，该参数是名为conv的一个Converter&lt;string, Giud&gt; 从各个名称可以看出，这个函数是可以把一组string数据转化成Guid数据。 泛型约束参数类型T是可以被约束的。即可以用约束来对T进行限制。在C# 中有4种约束。 引用类型约束 值类型约束 构造函数类型约束 转换类型约束 引用类型约束保证使用的类型实参必须是引用类型，该约束必须是类型参数指定的第一个约束。 1struct RefSample&lt;T&gt; where T : class 值类型约束保证使用的类型实参必须是值类型，包括枚举。 1class ValSample&lt;T&gt; where T : struct 构造函数类型约束它是所有类型参数的最后一个约束，它检查类型实参是否具有无参构造函数。这适用于所有值类型；没有显式声明构造函数的非静态、非抽象类；所有显式声明了一个公共无参构造函数的非抽象类。 1234public T CreateInstance&lt;T&gt;() where T: new()&#123; return new T();&#125; 转换类型约束这种约束允许你指定另一个类型，类型实参必须通过一致性、引用或装箱转换隐式地转换为该类型。 12class Sample&lt;T&gt; where T : Stream//所有Steam的派生类才可以做该类的类型实参 组合约束可以配合上述4种约束进行组合，但注意的是引用、值类型约束必须是第一个，构造函数约束必须是最后一个。 类型推断调用泛型方法时，指定类型实参有时会显得很多余，故有时可以不需要显式声明类型实参。类型推断只适用于泛型方法。 默认值表达式对于类型参数来说，有时候希望给其赋初值。但是往往会因为不同的类型实参，其初值也不尽相同。 使用default关键字来获取初值，即default(T)所返回的就是类型T的初值。 静态泛型字段如果一个泛型类有静态字段集，那么对于不同的封闭类型均有其自己的静态字段集。这样的规则也适用于静态初始化程序和静态构造函数。 JIT对泛型的处理对于不同的封闭类型，JIT则是将泛型类型的IL代码转换成本地代码，使其能真正运行起来。 具体的处理规则是：首先，所有的引用类型作为类型实参的封闭类型共享相同的本地代码，究其原因是所有的引用类型在栈上保存的只是它的引用，即4个字节（32位CLR）或8个字节（64位CLR）。其次，所有的值类型作为类型实参的封闭类型都会创建不同的代码。但是，JIT采用的是“懒人”原则，即只有当使用到对应的封闭类型才进行创建相关代码，一旦生成，就会缓存起来，以备下次使用。 泛型和反射typeof 关键字typeof关键字可用于获取某个类的类型，它返回的是System.Type对象的引用。在泛型中，既可以获取未绑定泛型的类型，也可以获取已构造类型的类型。要想获取未绑定泛型的类型，则不能带入相关的类型参数。比如： 123456789101112131415161718static void DemonstrateType&lt;X&gt;()&#123; Console.WriteLine(typeof(X)); // 未绑定的类型 Console.WriteLine(typeof(List&lt;&gt;)); Console.WriteLine(typeof(Dictionary&lt;,&gt;)); // 开放类型 Console.WriteLine(typeof(List&lt;X&gt;)); // 开放类型 Console.WriteLine(typeof(Dictionary&lt;string, X&gt;)); // 封闭类型 Console.WriteLine(typeof(List&lt;long&gt;)); Console.WriteLine(typeof(Dictionary&lt;long, Guid&gt;));&#125; 反射操作泛型对象在System.Type中，GetGenericTypeDefinition方法作用于已构造的类型，来获取它的泛型类型定义；MakeGenericType方法作用于泛型类型定义，返回一个已构造的类型。注意GetGenericTypeDefinition方法对两个相同的泛型类型定义构造出不同的封闭类型做操作，其返回结果是相同的，比如List&lt;int&gt;和List&lt;string&gt;数据。 反射操作泛型方法首先要获取泛型方法的定义，然后通过MakeGenericMethod来返回一个已构造的泛型方法。但有一点缺陷的是，针对只是类型参数数量不同的多个重载方法，没有直接的方式来获取指定类型参数数量的方法，通常只能获取所有的方法，然后再一步步找。 缺陷协变和逆变数组具有协变和逆变的，但是在 C# 2 中泛型并不具有相应的协变和逆变。直到 C# 4 中才具有了受限的协变和逆变。 缺乏操作符约束由于C#中操作符重载是以静态函数的形式出现的，因此目前来说，还没有操作符约束。这点在科学计算中很常见。","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/tags/读书笔记/"}]},{"title":"深入理解C#第二章：C# 1 所搭建的核心基础","slug":"CSharp In Depth/2-Core-foundations-building-on-CSharp","date":"2017-03-04T09:28:44.000Z","updated":"2017-03-04T12:39:06.773Z","comments":true,"path":"2017/03/04/CSharp In Depth/2-Core-foundations-building-on-CSharp/","link":"","permalink":"http://iskcal.github.io/2017/03/04/CSharp In Depth/2-Core-foundations-building-on-CSharp/","excerpt":"","text":"委托使用委托步骤委托使用分成4步： 声明委托类型 为委托实例的操作找到一个恰当的方法，即把什么方法挂载到委托上 创建委托实例 调用委托（Invoke 方法调用） 合并和删除委托一个委托可以挂载上多个符合要求的函数（即函数的参数个数、参数类型和返回值类型相同）。 System.Delegate类型的静态方法Combine和Remove函数可以向委托添加相应的函数。但这两个方法并不是在原委托上操作，而是生成一个新委托，因而委托是不易变的。 事件事件是对委托的进一步封装，它只允许在创建委托的类中调用委托，而在类外只能通过事件来把函数挂载到该委托上。 类型系统C# 1 的类型系统是静态的、显式的和安全的。 但C# 1 中有几点却不够用。 除数组外集合中只能是Object类型，这表示在内部可以装任意东西 缺乏协变和逆变 值类型和引用类型引用类型放在堆中，局部值类型放在堆栈中，引用类型中的值类型放在堆中。 值类型与object类型相互转化叫装箱和拆箱。装箱和拆箱会对性能有少许影响。","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/tags/读书笔记/"}]},{"title":"自控力 第一章：意志力","slug":"Self control/self-control-1","date":"2017-03-04T01:42:46.000Z","updated":"2017-03-04T12:39:06.773Z","comments":true,"path":"2017/03/04/Self control/self-control-1/","link":"","permalink":"http://iskcal.github.io/2017/03/04/Self control/self-control-1/","excerpt":"","text":"摘抄 所谓意志力，即“我要做”、“我不要”和“我想要”三种力量。 在意志力挑战中获胜关键，在于学会使用原始本能，而不是反抗这些本能。 在做决定的时候，你必须意识到自己此刻需要意志力。 如果你心里还在想着其他事，那么冲动就会主导你的选择。 认识自己，注意那些是自己真正想做的，那些是自己掩饰意图而做的，换句话来说，注意自己做某件事的真正意图。 任务 请选择一天，把做出来的决定记录下来。在这一天结束时，回想做出了哪些决定，分析哪些有利于你实现目标，哪些会消磨你的意志。坚持记录你的决定，还有助于减少在注意力分散时作决定，同时增强你的意志力。 利用一周的时间观察一下，你究竟如何屈服于冲动的。你甚至不用设定一个目标，只需要看看你能否及早意识到自己在做什么，什么样的想法、感受和情况最让你有冲动，想些什么或暗示什么最容易让你放弃冲动。 每天花5分钟训练大脑冥想 记录 2017-3-3 7:30 决定早起 — 成功但拖延，差点上课迟到，不想起来 7:50~9:25 上课 — 成功 9:30~12:00 技能学习 — 失败，上了半上午的网，当天nintendo switch发售，全程在网络浏览相关信息，以及观看相关开箱直播 12:30~14:00 午睡 — 失败，因为下午没课，不太想睡 14:30~17:30 回顾论文，写论文报告 — 失败，不太想去实验室，结果在宿舍玩了一下午 19:00~22:30 赶论文报告 — 完成 分析：早起还是需要的，个人感觉如果没有手机，可能执行效果会更好，接下来可能需要研究下如果没有手机如何查看时间的问题。上课不说了，技能学习需要找到一个点，感觉太大太空，需要再仔细琢磨琢磨。论文报告以后可以留在周五晚上写，没有必要在下午赶出来。 通常会喜欢拖延，拖延拖延往往到最后就屈服冲动了。很多时候拖延会意识到，但是一想拖一会儿没什么就这么拖延下去了。还有对能否做完一件事抱有疑问，不自信，认为自己没有能力完成。 效果感觉不是很好，但还是要坚持做下去。","categories":[{"name":"读书","slug":"读书","permalink":"http://iskcal.github.io/categories/读书/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"},{"name":"book","slug":"book","permalink":"http://iskcal.github.io/tags/book/"}]},{"title":"《解忧杂货店》 观后感","slug":"life/worrybook","date":"2017-02-28T12:17:06.000Z","updated":"2017-03-04T12:39:06.773Z","comments":true,"path":"2017/02/28/life/worrybook/","link":"","permalink":"http://iskcal.github.io/2017/02/28/life/worrybook/","excerpt":"","text":"关于这本书，以前听说过，评价还不错，正好亚马逊也给我推荐了这本书，于是我就拿来读读看看了。结果发现，这本书越看越不错，花了两天整的时间把读完了，反正也没啥事，写写一些感想吧。 不得不说，《解忧杂货店》这本书条理清晰，阅读顺畅。其作者东野圭吾是一个写推理小说的作家，虽说这本书不是推理小说，但是整篇故事下来也可以看出作者在逻辑上的处理实力。 本书一共五个故事，五个看似单独不相关的故事，但是实际上都是发生在一个小镇中的事情。（前方有剧透） 第一个故事故事讲述的是在小镇中有一个废弃的杂货铺，名叫浪矢杂货铺。有一天，有三个小偷偷了东西后躲了进去，之后收到了一条远在过去的信，也就是说他们在与几十年前的人通信。信中讲述了一个女子在追求梦想和照顾身患绝症的男友之间做出抉择的事情。原来女子听说该杂货店能解决人烦恼，便把自己的烦恼告诉杂货铺，希望能得到指点。 故事是从三个小偷的角度叙述的，这篇故事作为开头，与其说是咨询烦恼，还不如说是给三人练手用的。 令我惊奇的是结尾，三人因知道之后几十年发生的事情，劝说她去照顾她男朋友。但是如果真心相爱的两个人，那么病床上的他真的愿意他所喜欢的人为了他放弃自己的理想么。 “我比任何人都要爱你，想要永远和你在一起。如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望我坚持我的梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘过你，但请让我去追逐梦想吧。” 虽然最终，她没有能参加奥运会，男朋友也去世了，但是按照她自己的话来说，就是“他最后对我说的那句谢谢你带给我的梦想，还有临终时满足的表情，对我来说就是最大的奖赏”。 第二个故事说真，第二个故事可以说是我印象中最深的一个了。一个为了梦想不顾一切的人，为了音乐，努力学习，为了音乐，放弃学业，为了音乐，在酒吧卖唱。看看开头，多像一个鸡汤文，然后被某某星探发现，从此就成为了一个著名的音乐人。但是这里啊，主角只是一个普通人，普通到专业人士只认为他的水平一般，走歌手路子行不通。 故事以奶奶的葬礼开始的，就像一些文章中落魄的主角一样，回到老家，看似父母的强烈反对学音乐，实际上也能看出父母希望他能坚持他的梦想。于是他向杂货铺咨询，三人因知未来事，劝他在家子继父业，然而在最后一封信中却给出了这样一段文字： 你对音乐的执着追求，绝不是白白付出。我相信，将会有人因为你的歌而得到救赎。你创作的音乐也必将流传下去。若要问我为何能如此断言，我也很难回答，但这确实是事实。请你始终坚信这一点，坚信到生命的最后一刻。 回过头来再看看这段话，确实令人感慨。主角在孤儿院用生命拯救了一个小男孩，而这位男孩的姐姐在未来成为了一个歌星，并将主角创作的那首《重生》之歌流芳百世。 “你的穷途末路，却带给其他人未知的过往”。 第三个故事第三个故事讲述了杂货店接受咨询的起因，可以说是整本书的开头，老爷爷因偶然开始了咨询，但对待每个人每件事都是认真的。开始还是因为能帮助他人解决问题而特别高兴，但是随后却担心他人因自己的话语而走上并不幸福的道路。 借着咨询角度，这里又讲述了一个故事，故事里一个母亲说她怀了一个已婚之夫的孩子，她来咨询问到底要不要生出来，老爷爷并没有明确说明，只是说如果你确定要生下来，那么就要想好如何能照顾好他。可是在孩子生下不久，就因车祸去世了，万幸的是孩子没有事。但孩子一直以为母亲是带她一心赴死而埋恨她，直到最后孩子才发现母亲为了让她能存活下来，主动赴死。 “决定好了一件事，就要全力以赴地去做。” 第四个故事第四个故事讲述了亲情，这也是我印象中比较深的一个。 主角原本是家庭富裕的一家人，可是到了某天才发现，家里已经欠了不少钱。父母要带着主角跑路，隐姓埋名，然而主角埋怨父母，一个人跑了，从此成了一个孤儿。他原以为父母会隐姓埋名下来，等风头过了再去寻找他。结果最后得知，父母为了保护他，不惜以二人的死亡来彻底隐匿主角的身份。 “亲情，是可以超越生死的。” 第五个故事第五个故事把所有故事都给串起来了。 有一个女子来咨询如何获得经济独立，三人并不建议她去陪酒，并说，如果你相信我，那么我给你指一条路。女子后来听信了他们，并获得了巨大的成功，有一天她想回报当初帮助她的孤儿院，但是被他人诬陷。孤儿院中的三个小偷听信恶人，于是潜入她家偷东西，最后他们发现她就是当初他们帮助的那个人。整个故事刚好圆成了一个圈。 最后小偷三人测试性的递入了空白的资讯信，但是老爷爷给了一个非常漂亮的回答：因为你们还是一张白纸，因此你们可以随心所欲地描绘地图。整篇故事完结。 最后一个故事其实既说了三人组，也说了我们自己吧。 我想，整本书与其说是一个故事，更不如说是一部童话，治愈着人的心灵。","categories":[{"name":"读书","slug":"读书","permalink":"http://iskcal.github.io/categories/读书/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"},{"name":"book","slug":"book","permalink":"http://iskcal.github.io/tags/book/"}]},{"title":"深入理解C#第一章：C#开发的进化史","slug":"CSharp In Depth/1-The-changing-face-of-CSharp-development","date":"2017-02-27T10:58:24.000Z","updated":"2017-02-27T11:30:25.000Z","comments":true,"path":"2017/02/27/CSharp In Depth/1-The-changing-face-of-CSharp-development/","link":"","permalink":"http://iskcal.github.io/2017/02/27/CSharp In Depth/1-The-changing-face-of-CSharp-development/","excerpt":"","text":"本章着重讲解C# 1到C# 5中的变化，微软为了让编写代码变得更加容易，在每个版本更迭中所添加的功能有一部分都在围绕如何让代码写起来更加的简单优雅。不仅如此，C# 每个版本中还会添加一些新的功能从而简化代码逻辑。 代码演化由于本章是第一章，并不会着重讲述C#后续版本的特性，这里只提供一个大致的同一个功能的代码来描述各版本之间代码的异同以及为什么需要这样的变化。 老规矩，用产品、名称和价格的例子来作为描述对象。 原始代码12345678910111213141516171819202122232425262728293031//CSharp 1using System.Collections;public class Product1&#123; string name; public string Name &#123; get &#123; return name; &#125; &#125; decimal price; public decimal Price &#123; get &#123; return price; &#125; &#125; public Product1(string name, decimal price) &#123; this.name = name; this.price = price; &#125; public static ArrayList GetSampleProducts() &#123; ArrayList list = new ArrayList(); list.Add(new Product1(\"West Side Story\", 9.99m)); list.Add(new Product1(\"Assassins\", 14.99m)); list.Add(new Product1(\"Frogs\", 13.99m)); list.Add(new Product1(\"Sweeney Todd\", 10.99m)); return list; &#125; public override string ToString() &#123; return string.Format(\"&#123;0&#125;: &#123;1&#125;\", name, price); &#125;&#125; 这是最简单的C#代码，我相信很多人哪怕已经接触了更高的版本后仍会写出这样的代码，但这段代码有几个缺陷： ArrayList没有提供与内部内容有关的编译时信息。换句话而言，ArrayList内部保存的是基类Object，你可以往其内部添加任何玩意并不出错，但显然这不是我们所希望的。 代码内添加了公共的取值方法，这意味着如果添加对应的赋值方法，这也得是公共的。 创建属性和变量的代码很复杂。封装一个字符串和一个十进制数应该是是简单的任务，不需这么复杂。 第一次改进12345678910111213141516171819202122232425262728293031323334353637//CSharp 2public class Product2&#123; string name; public string Name &#123; get &#123; return name; &#125; private set &#123; name = value; &#125; //新的赋值权限 &#125; decimal price; public decimal Price &#123; get &#123; return price; &#125; private set &#123;price = value; &#125; //新的赋值权限 &#125; public Product2(string name, decimal price) &#123; Name = name; Price = price; &#125; public static List&lt;Product2&gt; GetSampleProducts() //采用泛型约束内部数据类型 &#123; List&lt;Product2&gt; list = new List&lt;Product&gt;(); list.Add(new Product2(\"West Side Story\", 9.99m)); list.Add(new Product2(\"Assassins\", 14.99m)); list.Add(new Product2(\"Frogs\", 13.99m)); list.Add(new Product2(\"Sweeney Todd\", 10.99m)); &#125; public override string ToString() &#123; return string.Format(\"&#123;0&#125;: &#123;1&#125;\", name, price); &#125;&#125; 这样一来，属性有了私有的赋值方法，并且集合内部约束了基本的数据类型，这样不能添加非Product类对象。C# 2解决了原先代码中的2个问题。还有一个问题，C# 3解决。 第二次改进123456789101112131415161718192021222324//CSharp 3public class Product3&#123; public string Name &#123; get; private set; &#125; public decimal Price &#123; get; private set; &#125; //属性创建缩短为一行 public Product3() &#123;&#125; //新的构造函数，和书中不同，这里函数是public的 public static List&lt;Product3&gt; GetSampleProducts() &#123; return new List&lt;Product3&gt; &#123; new Product3&#123; Name=\"West Side Story\", Price=9.99m&#125;, new Product3&#123; Name=\"Assassins\", Price=14.99m&#125;, new Product3&#123; Name=\"Frogs\", Price=13.99m&#125;, new Product3&#123; Name=\"Sweeney Todd\", Price=10.99m&#125;, &#125;; //新的集合构造表达式 &#125; public override string ToString() &#123; return string.Format(\"&#123;0&#125;: &#123;1&#125;\", Name, Price); //属性当正常的字段使用 &#125;&#125; 现在，属性已经不会和任何的变量相关联，因此代码中原先所有的使用字段的地方都改成属性。 第三次改进 （新加）但这里有个缺陷，当如果我们希望生成一个Product对象中就带有初值，而不需要在构造函数中给出，这种情况往往用于有些参数变量取默认值就好而不需要手动指明默认值。C# 6中属性的自动初始化可完成这个任务。 123456789101112131415161718192021222324//CSharp 6public class Product6&#123; public string Name &#123; get; private set; &#125; = \"Sweeney Todd\"; public decimal Price &#123; get; private set; &#125; = 13.99m; //属性赋初值 public Product() &#123;&#125; //新的构造函数，和书中不同，这里函数是public的 public static List&lt;Product6&gt; GetSampleProducts() &#123; return new List&lt;Product6&gt; &#123; new Product6&#123; Name=\"West Side Story\", Price=9.99m&#125;, new Product6&#123; Name=\"Assassins\", Price=14.99m&#125;, new Product6&#123; Name=\"Frogs\", Price=13.99m&#125;, new Product6&#123; Name=\"Sweeney Todd\", Price=10.99m&#125;, &#125;; &#125; public override string ToString() &#123; return $\"&#123;Name&#125; : &#123;Price&#125;\"; //新的字符串生成方法，类似于php中的操作 &#125;&#125; 当新建一个Product对象时，属性Name和Price就会赋上给定的相应初值，注意这个赋值操作是直接对字段操作而不是通过赋值属性操作而来的。 剩余部分本书之后还提到了C# 4中的命名实参，但我个人感觉C# 4中最大的特性不在于这而在于动态编程，因而这里不太细说了。 以上只是举了一个简单的例子来描述C#中各版本内的变化，不仅仅是以上提到的改动，还有一些比较大的改进。比如说委托在C# 1到C# 4几乎都有变化，甚至有些改动形成了一种新的编程方式，比如Linq，异步编程等。 后续部分我并没有说，不是说我认为不重要，而是因为我认为这些新特性会在后续章节详细说到，本章只作为引出开头，笔记做到这里就可以了。","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/tags/读书笔记/"}]},{"title":"深入理解C# 各章汇总","slug":"CSharp In Depth/0-Abstract","date":"2017-02-27T02:49:56.000Z","updated":"2017-03-18T03:03:48.918Z","comments":true,"path":"2017/02/27/CSharp In Depth/0-Abstract/","link":"","permalink":"http://iskcal.github.io/2017/02/27/CSharp In Depth/0-Abstract/","excerpt":"","text":"这是我第一次开始尝试正式阅读一本书，嗯，以前多多少少看过一点书，但是经常看不了多少就放弃了，总觉得自己看不进去，也不能坚持下来。这次索性就边看边记录，看看自己能坚持多久。所谓好记性不如烂笔头，只看不写确实让人提不起什么兴趣。好了废话不多说，正式开始吧。 本书主要讲解的是C# 2及后续版本的更新要素。当初微软在创建C#之时，是以Java为蓝本抄袭过来的，因而C# 1的大多数功能和Java类似，之后便从C# 2开始加入了一系列的新特性和新功能，新的内容便是本书着重讲解的部分。 由于这本书出的已经有了几年了，C# 也从1发展到7了，但本书只讲述了C# 1 到C# 5 的情况，由于C# 7 暂时还未正式发布，并且 C# 6和C# 7 添加的功能不太多，很多东西属于语法糖的程度，因而我个人会在最后结尾处稍微提及一下。 本书分为五个部分和三个附录。五个部分基本对于C# 1到C# 5，附录列出了所有的参考资料，这里不做多叙述。 第一部分：基础知识这一部分主要讲述了C#的一些基础性知识以及C# 1中的概念，这是为后续的C# 版本做铺垫。 第一章: C#进化史第二章：C# 1 所搭建的核心基础 第二部分：解决C# 1 中的问题这一部分主要讲述了C# 2 中的几个重大新特点：泛型、可空类型、委托、迭代器以及其他小特性 第三章：用泛型实现参数化类型第四章：可空类型[第五章：进入快速通道的委托][5][第六章：实现迭代器的捷径][6][第七章：结束C# 2的讲解：最后一些特性][7] 第三部分： C# 3：革新写代码的方式这一部分整个C# 3 基本在围绕着Linq所服务的，并且其中很多特性在Linq之外也可以使用 [第八章：用智能的编译器来防错][8][第九章：Lambda表达式和表达式树][9]","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://iskcal.github.io/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://iskcal.github.io/tags/读书笔记/"}]},{"title":"python函数中*号作用","slug":"wiki/python-star","date":"2017-02-26T13:21:54.000Z","updated":"2017-03-04T12:39:03.000Z","comments":true,"path":"2017/02/26/wiki/python-star/","link":"","permalink":"http://iskcal.github.io/2017/02/26/wiki/python-star/","excerpt":"","text":"Python中既可以在实参中使用*，也可以在形参中使用*。 形参中使用星号这种使用方式比较常见。它可以看成是实参的打包。即该形参变量对应多个实参。 12345678def function1(*a, **b): print(a) print(b)func(1,2,3,x=10,y=11)# 输出# (1,2,3)# &#123;'x': 10, 'y': 11&#125; 实参中使用星号这种使用方式并不太常见。它可以看成是实参的解包。即一个实参对应多个形参 12345678def function2(a, b, c, x, y): print(\"%s %s %s %s %s\" % (a, b, c, x, y))p1 = [1, 2, 3]p2 = &#123;'x': 10, 'y': 11&#125;function2(*p1, **p2)# 输出：1 2 3 10 11 这种方式常用于配置信息中，比如说被调用函数只需要它所要的配置信息数据，而调用时可以把整个配置信息字典传过去，方便代码编写。","categories":[{"name":"wiki","slug":"wiki","permalink":"http://iskcal.github.io/categories/wiki/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"}]},{"title":"kindle","slug":"life/kindle","date":"2017-02-26T12:21:15.000Z","updated":"2017-03-04T12:39:06.773Z","comments":true,"path":"2017/02/26/life/kindle/","link":"","permalink":"http://iskcal.github.io/2017/02/26/life/kindle/","excerpt":"","text":"元宵前买的kindle到今天终于到了，亚马逊似乎这款kindle卖的挺火的，一直无货，我隔了几乎有两个多星期才拿到手。 说起来，去年有想买kindle的念头，但是一直犹犹豫豫的，今年总算下定决心买来一个玩玩。之所以想买这个，纯粹就是希望自己能够多看点书吧。 另外，保护套颜色总感觉有点怪怪的，颜色太淡了，感觉适合女生用。嘛，算了，已经拿了，就凑合着用吧。 买了两本书，一本和心理学相关，叫《自控力》；另一本好像是小说，还没看，叫《解忧杂货铺》。前者看了一点，感觉还有点启发，要不回头试试写写笔记？后者还没看，不过听说口碑不错，好像还要改编成电影，也趁好提前看看。 以前总觉得书这种东西，只看专业书籍就行了，其他的书籍都在浪费时间。嗯，今年倒是想看看一些其他方面的书了，就当培养点耐心和爱好，拓展下视野吧。毕竟想改变也得做才行啊。 kindle","categories":[{"name":"生活","slug":"生活","permalink":"http://iskcal.github.io/categories/生活/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"}]},{"title":"python中的装饰器","slug":"python-decoration","date":"2017-02-25T02:53:37.000Z","updated":"2017-02-27T02:33:25.000Z","comments":true,"path":"2017/02/25/python-decoration/","link":"","permalink":"http://iskcal.github.io/2017/02/25/python-decoration/","excerpt":"","text":"装饰器的由来装饰器的出现，主要是由于两大原因。一是我们希望在调用一个函数前后执行某种逻辑操作，比如说验证信息、统计函数执行时间；二来这种操作非常普遍，普遍到有大量的函数都需要这种逻辑。如果说我们在每个函数前后都编写这样的逻辑，会产生复制-粘贴的结果，这种情况下对共有逻辑的修改是非常不利的。在Python中提供了装饰器来减少这种代码，使得那些需要同一个逻辑的函数只需要共用一份代码，共有逻辑的修改仅仅需要一次即可。 装饰器的构造我们先通过一个例子来看看装饰器，该例子所用的装饰器是计算某个函数一共调用了多少次，并在函数执行完毕后输出次数。 1234567891011121314151617181920212223# 装饰函数，计算给定的函数调用多少次def recordCall(func): count = 0 def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter@recordCall# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用testFunction()# 输出# Hello world!# 第2次调用 这个例子的代码和之前闭包几乎完全一样，但是这里在第11行的语句确是原先没有的，但实际上这句话就是一个语法糖，它等价于testFunction = recordCall(testFunction)。因此，在这句话里面，实际上可以认为它把testFunction函数挂到counter方法体上了，执行testFunction函数并不是执行原本的函数体，而是counter方法体。这样达到了函数计数的目的。 带参的装饰器有很多时候，往往装饰函数内部的数据也希望不是固定的，我们希望有些参数是外部传进来的而不是取固定值。比如说上例中，我们默认count变量是从0开始取值的，但有时候我们希望这个值是外部给出的而不是写死的。其思路也很简单，我们可以把上面的装饰器看成是一个特定值的装饰器，然后在该装饰器外面再套一个函数用于给定数据变量就行了。 1234567891011121314151617181920212223242526# 外层装饰函数，用于输入确定值def deco(start):# 装饰函数，计算给定的函数调用多少次 def recordCall(func): count = start def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter return recordCall@deco(5)# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第6次调用testFunction()# 输出# Hello world!# 第7次调用 例子中展现的就是装饰器带参数，这种情况下还是比较多的，比如说在Flask框架中，用参数来指明某个函数应用于哪个路由。 多装饰器组合使用由于装饰完成后仍是一个函数，仍可以用装饰器再装饰，因此可以使用多个装饰器来修饰一个函数，也可以使用多个同一个装饰器来修饰一个函数，比如上例： 1234567891011121314151617181920212223242526def deco(start): def recordCall(func): count = start def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter return recordCall@deco(5)@deco(0)def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用# 第6次调用testFunction()# 输出# Hello world!# 第2次调用# 第7次调用 多装饰器的调用顺序是外部函数自底向上的，内部函数自顶向下的。这里，装饰的顺序是，首先testFunction函数会被deco(0)所装饰，所得函数会被deco(5)再次装饰。由于print语句位于内部函数中，因此内部函数执行顺序为先执行count = 0的counter函数，再执行count=5的counter函数。 Python 内置装饰器在 Python 中有一个内置的常用装饰器wraps。在说明这个装饰器之前，我们回到初始的例子。在初始代码执行完毕后，执行下面这句话： 1234... # 原先代码print(testFunction.__name__)# 输出： counter 这句话的意思是打印这个函数的名字，可以看到，这个函数名字已经被修改成counter而不是原本的testFunction。可能一般情况下编程没有什么，但是一旦扯上反射，通过名字来寻找相应函数就会出现问题。我们希望该函数的名字仍是其原本的函数，这样可以使用wraps装饰器来解决。 1234567891011121314151617181920212223242526272829import functools# 装饰函数，计算给定的函数调用多少次def recordCall(func): count = 0 @ functools.wraps(func) def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter@recordCall# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")testFunction()# 输出# Hello world!# 第1次调用testFunction()# 输出# Hello world!# 第2次调用print(testFunction.__name__)# 输出： testFunction","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"}]},{"title":"Python中的闭包","slug":"python-closure","date":"2017-02-24T06:45:27.000Z","updated":"2017-02-27T03:21:02.278Z","comments":true,"path":"2017/02/24/python-closure/","link":"","permalink":"http://iskcal.github.io/2017/02/24/python-closure/","excerpt":"","text":"什么是闭包闭包这个概念，在函数式编程语言用的非常多，由于Python也具有一定的函数式编程的能力，自然也就会有闭包了。 我们先来看看闭包是啥。简而言之，即某个函数A返回一个函数B，但函数B包含一些函数A中的变量。用Python代码表示为： 123456789def line_config(k, b): def line(x): return k*x+b return lineline1 = line_config(2, 0)print(line1(4)) # 输出8line2 = line_config(1, 0)print(line2(3)) # 输出3 可以看到，这里在line_config函数内部又定义了一个line函数。不仅如此，还有在line函数内部使用了其外部函数中的k和b变量。我们在line_config函数的范围内定义了函数line只能在line_config函数作用范围内使用。但实际情况是，内部定义的函数不仅可以在外部使用（第6行），而且还可以在外部调用时仍可以使用之前已经执行完成的k和b变量，这两点并不符合变量作用域范围的常识。这里，我们把这两个不符合作用域范围的变量k和b称之为环境变量，而内部的line函数和其环境变量合在一起，就形成了一个闭包(closure)。 闭包有什么用呢很多人初次见到闭包，往往只认为它是一种新特性，并且这种特性似乎只增加了一种新概念，对于编程似乎没有多大的提升，反而使得简单的问题复杂化。那么为什么要有闭包呢？一个字，懒。这种新特性只是简化代码的编写，并使得可读性变得更强。其具体体现在Python的一个强大的功能：装饰器，关于装饰器这里暂且不表。我们就对上面的一个例子做个分析吧。 有人肯定会说，上面的例子太麻烦了，写成下面这样的更好： 12def line(k, b, x): return k*x + b 看起来，下面这种代码非常少，仅仅2行足矣。但是如果有大量的线性函数需要表达，并且未来涉及到改动，那么后者的改动量实在太大了。举个例子，有50个线性函数，每个函数计算100个点，假如需要把某个函数进行修改，那么只修改一个函数后者就需要操作100次，而前者仅仅需要一次即可。 我们来看看闭包的代码，第6、7行相当于定义了一个线性函数。第7、9行相当于给定了一个x值，通过线性函数计算对应的y值。可以看出之后调用时斜率与截距会默认保存下来，也就是说内部函数保存了一个上下文环境，这个环境是实例性的，即不同的调用会产生不同的上下文，形成不同的线性函数。 nonlocal 语句在Python中，内部函数默认是可以读自由变量的，但是并没有办法写。在 Python 2 中只能将这个自由变量提升到全局变量，但是这种方法潜在危害性太大，毕竟没有哪一门语言提倡使用全局变量。Python 3 中给出了另一种方法，使用 nonlocal 语句。举个例子： 1234567891011121314151617181920212223# 闭包，用于记录func函数被调用了多少次def recordCall(func): count = 0 def counter(): nonlocal count count += 1 func() print(\"第%d次调用\" % count) return counter# 测试函数，结合闭包，用于测试该函数调用多少次def testFunction(): print(\"Hello world!\")callTime = recordCall(testFunction)callTime()# 输出# Hello world!# 第1次调用callTime()# 输出# Hello world!# 第2次调用 这是一个闭包非常常用且实际的例子，这里的闭包用于记录传入的函数（Python中可以把函数当作对象传入函数中）被调用多少次。这里其实有一点装饰器的影子。注意内部的函数，nonlocal语句用于查找其自由变量，接下来的语句就是对其进行修改赋值，再然后执行传入的函数，输出次数，逻辑就这么多。可以看到使用闭包后，可以对任意一个函数记录其次数，但是仍有漏洞，如果调用原来的testFunction，发现并不会记录次数。改进的方法也很简单，只需要把callTime改成原来的testFunction即可，即第15行改为testFunction = recordCall(testFunction)，那么在此之后，任意地方调用testFunction()都会记录次数并输出次数。 循环与闭包在闭包这里，还需要说明的一点是，闭包只保存自由变量，并不保存自由变量的值。当调用内部函数时，才会去寻找自由变量的值。这点非常具有迷惑性，下面就是一个例子。 123456789101112def wrapper(): arr = [] for i in range(3): def square(): return i*i arr.append(square) return arrresult = wrapper()print(result[0]()) # 输出 4print(result[1]()) # 输出 4print(result[2]()) # 输出 4 头有点大，我们慢慢来看。首先先不管square函数，我们先只看wrapper函数，这个函数很一般，我们定义了一个列表arr，并用循环向内部添加了3个东西。之后，再看square函数，它定义在循环体内部，列表添加的是函数而不是值（append函数内部参数是square而不是square()，前者是函数，后者是值）。然后，函数的计算方式是序号的平方。最后调用这个函数，输出三个值，但是发现这三个值并不是 0,1,4 而是 4,4,4。这和我们的思考方式并不一样。 当然了，这里已经说过了自由变量会在调用的时候才会去查找相关值。因此，在第一次调用result[0]()这个函数时，它才会寻找i的值，此时i的值为2，返回4。之后几次调用，由于i值不变，因而都会返回4。如果要想实现我们之前所想的功能，只需要使用给定默认值即可，如下面代码，Python会在调用时保存相关的i值数据。 12345678910111213# 默认参数def wrapper(): arr = [] for i in range(3): def square(i=i): return i*i arr.append(square) return arrresult = wrapper()print(result[0]()) # 输出 0print(result[1]()) # 输出 1print(result[2]()) # 输出 4","categories":[{"name":"技术","slug":"技术","permalink":"http://iskcal.github.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"http://iskcal.github.io/tags/python/"}]},{"title":"博客正式启动啦","slug":"life/start","date":"2017-02-22T10:20:28.000Z","updated":"2017-02-22T10:29:16.914Z","comments":true,"path":"2017/02/22/life/start/","link":"","permalink":"http://iskcal.github.io/2017/02/22/life/start/","excerpt":"","text":"博客启动 本博客正式启动了，虽然功能还有一些未完善，但是先跑起来再说吧。目前想法是在这里记录生活、学习、爱好等，把这里作为我自己的时间记录吧。就这样，加油。","categories":[{"name":"生活","slug":"生活","permalink":"http://iskcal.github.io/categories/生活/"}],"tags":[{"name":"life","slug":"life","permalink":"http://iskcal.github.io/tags/life/"}]}]}